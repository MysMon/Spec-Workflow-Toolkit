---
description: "体系的なデバッグワークフロー - エラー分析、根本原因の追跡、サブエージェント委任による修正実施"
argument-hint: "<エラーメッセージ or --test 'テスト名' or --file 'パス'>"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, AskUserQuestion, Task, TodoWrite
---

# /debug - 体系的デバッグコマンド

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

サブエージェント委任を活用してエラーを分析し、根本原因を追跡し、検証済みの修正を実施する構造化デバッグワークフロー。

## 設計原則

1. **スタック非依存**: あらゆる言語/フレームワークで動作
2. **推測する前に発見する**: プロジェクトのテスト/ビルドコマンドを検出
3. **まず根本原因を特定**: 修正を実施する前に原因を特定
4. **修正を検証する**: 修正が機能することを必ずテスト

---

## 使用するとき

- スタックトレース付きのランタイムエラー
- テスト失敗
- 予期しない動作
- パフォーマンスの問題
- ビルド/コンパイルエラー

## 入力形式

```bash
# エラーメッセージ
/debug "Error: Something went wrong"

# スタックトレース（直接貼り付け）
/debug
[スタックトレースを貼り付け]

# 失敗するテスト
/debug --test "TestName"

# 疑わしいファイル
/debug --file path/to/file

# 動作の説明
/debug "X が期待されるが Y が返る"
```

---

## 実行手順

### フェーズ 1: エラー分類

**ゴール:** エラーの種類と範囲を把握する。

**入力を解析して以下を特定する:**

| 入力タイプ | 指標 | 分析アプローチ |
|-----------|------|--------------|
| スタックトレース | ファイルパス、行番号、関数呼び出し | 実行パスを追跡 |
| エラーメッセージ | エラータイプ、メッセージテキスト | 類似パターンを検索 |
| テスト失敗 | テスト名、アサーション | テストを実行し失敗を分析 |
| 動作 | 期待値と実際の動作の説明 | 関連コードを探索 |

**エラーカテゴリの分類:**

```
カテゴリ:
1. ランタイムエラー - 実行中にコードがクラッシュ
2. ロジックエラー - 結果が誤り、クラッシュなし
3. テスト失敗 - 自動テストが失敗
4. ビルドエラー - コンパイル/バンドルが失敗
5. 連携エラー - 外部サービスとの連携が失敗
6. パフォーマンス - 処理が遅い、またはリソース集約的
```

### フェーズ 2: コンテキスト収集

**ゴール:** サブエージェント委任により関連コンテキストを収集する。

**`code-explorer` エージェントに委任する:**

```
code-explorer エージェントを起動して分析:

エラーコンテキスト: [エラーメッセージ/スタックトレース]
分類: [エラーカテゴリ]

タスク:
1. エラーのソースを特定（利用可能ならスタックトレースの file:line）
2. エラーに至る実行パスを追跡
3. 関連する関数とデータフローを特定
4. コードベースで正常に動作する類似パターンを検索
5. 影響を受けるファイルの最近の変更（git log）を確認

網羅度: medium
出力:
- file:line 付きのエラー箇所
- 実行パス
- 関連するコードパターン
- 可能性の高い順に並べた潜在的原因
```

**テスト失敗の場合:**

上記の code-explorer タスクにテストコマンドの探索を含める。エージェントはプロジェクトのテストフレームワークとコマンドを特定する。

**環境コンテキストの収集を code-explorer に委任する:**

```
code-explorer エージェントを起動（上記に含まれていない場合）:
タスク: デバッグ用の環境コンテキストを収集
分析内容:
- 最近の git 変更（直近10コミット）
- 未コミットの変更（git diff --stat）
- パッケージマネージャーとロックファイル
- 依存関係の問題
網羅度: quick
出力: 環境コンテキストのサマリー
```

コンテキスト収集にはエージェントの出力を使用する。手動で git/grep コマンドを実行してはならない。

### フェーズ 3: 根本原因分析

**ゴール:** 修正を試みる前に根本原因を特定する。

**code-explorer の調査結果を分析する:**

エージェントの出力に基づき以下を特定する:

1. **直接的原因**: エラーを直接引き起こしたもの
2. **根本原因**: その状況が発生した理由
3. **寄与要因**: バグを可能にしたその他の条件

**CRITICAL (L1): 根本原因の候補が複数ある場合は必ず AskUserQuestion を使用する:**

```
Question: "潜在的な原因を見つけました。どのシナリオがあなたの状況に合致しますか？"
Header: "根本原因"
Options:
- "[原因 A]: [説明]"（分析に基づき最も可能性が高い）
- "[原因 B]: [説明]"
- "[原因 C]: [説明]"
- "いずれでもない / さらなる調査が必要"
```

**どの根本原因が正しいか推測してはならない — 必ずユーザーに確認する。**

**根本原因を文書化する:**

```markdown
## 根本原因分析

### 直接的原因
[エラーを直接引き起こしたもの]
ファイル: `[file:line]`

### 根本原因
[直接的原因が発生した理由]

### 根拠
- [根拠 1]
- [根拠 2]
```

### フェーズ 4: 修正計画

**ゴール:** 実施前に修正戦略を設計する。

**原因に基づいて修正アプローチを決定する（技術ではなく原因に基づく）:**

| 根本原因の種類 | 修正アプローチ |
|--------------|--------------|
| バリデーション不足 | 防御的チェックを追加 |
| ロジック/アルゴリズムの誤り | ロジックを修正 |
| エラーハンドリング不足 | エラーハンドリングを追加 |
| 型/データの不一致 | 型または変換を修正 |
| レースコンディション | 同期処理を追加 |
| 依存関係の不足 | インポート/インストールを追加 |
| 設定エラー | 設定値を修正 |

**TDD アプローチの検討:**

```
TDD フロー（非自明なバグに推奨）:

1. バグを再現するテストを作成する
2. テストが失敗することを確認する
3. 修正を実施する
4. テストが通ることを確認する
5. リグレッションのためフルテストスイートを実行する
```

**ユーザーにアプローチを確認する:**

```
Question: "修正にどうアプローチしますか？"
Header: "修正アプローチ"
Options:
- "TDD: まず再現テストを作成する"（推奨）
- "直接修正: すぐに修正を実施する"
- "さらに探索: 追加分析が必要"
- "説明のみ: コードは変更しない"
```

### フェーズ 5: 修正の実施

**ゴール:** 適切なエージェント委任により修正を実施する。

**コードの場所に基づいて適切なスペシャリストに委任する（想定技術ではなくコードの場所に基づく）:**

```
まず code-explorer に委任して判断:
- これはどの種類のコードか？（フロントエンド/バックエンド/テスト/設定）
- このコードベースではどのパターンが使われているか？

次に適切なスペシャリストに委任:
- フロントエンドコード → frontend-specialist
- バックエンドコード → backend-specialist
- インフラ → devops-sre
- テストコード → qa-engineer
```

**TDD アプローチの場合:**

```
ステップ 1: qa-engineer に委任
タスク: このバグを再現するテストを作成する

ステップ 2: テストが失敗することを確認
プロジェクトのテストコマンドで新しいテストを実行

ステップ 3: 適切なスペシャリストに委任
タスク: このテストが通るようにバグを修正する

ステップ 4: 修正を確認
新しいテストを実行し、通ることを確認
フルテストスイートを実行し、リグレッションがないことを確認
```

### フェーズ 6: 検証

**ゴール:** 修正が機能することを確認する。

**検証コマンドを code-explorer で探索する（grep を直接実行してはならない）:**

```
code-explorer エージェントを起動:
タスク: プロジェクトの検証コマンドを探索
分析内容:
- テストコマンド（package.json scripts、Makefile、pytest.ini 等）
- ビルドコマンド（package.json scripts、Makefile 等）
- リントコマンド（package.json scripts、リンター設定）
網羅度: quick
出力: 利用可能なコマンドとその実行方法のリスト
```

利用可能な検証コマンドの判断にはエージェントの出力を使用する。親コンテキストで grep コマンドを直接実行してはならない（128行目のルールに従う）。

**探索されたコマンドを実行して修正を検証する**（実行は可能、探索は委任）。

**修正後にテストが失敗した場合:**

1. 新しい失敗を分析する
2. リグレッションか無関係かを判断する
3. リグレッションの場合: 修正を反復する
4. 無関係の場合: 別途調査として記録する

### フェーズ 7: サマリー

**ゴール:** 実施内容を文書化する。

```markdown
## デバッグサマリー

### バグ
[元のエラー/説明]

### 根本原因
[バグの原因]
ファイル: `[file:line]`

### 適用した修正
[変更内容]

### 変更ファイル
| ファイル | 変更内容 |
|---------|---------|
| `[パス]` | [説明] |

### 検証
- [ ] 再現テスト作成済み（TDD の場合）
- [ ] 修正後にテスト合格
- [ ] フルテストスイート合格
- [ ] リグレッション未検出

### 推奨事項
[フォローアップアクション]
```

**コミットについて確認する:**

```
Question: "修正は検証済みです。コミットしますか？"
Header: "コミット"
Options:
- "はい、修正をコミットする"
- "いいえ、まずレビューします"
- "差分を見せてください"
```

---

## エラー別ワークフロー

### スタックトレースのデバッグ

```
1. スタックトレースを解析:
   - エラータイプとメッセージ
   - ファイルパスと行番号
   - 関数呼び出しの順序

2. 最上位（最新の呼び出し）から開始
3. 各レベルのコードを読む
4. 期待と実際の動作が乖離した箇所を特定
```

### テスト失敗のデバッグ

```
1. テストを探索し詳細出力で実行
2. 以下を特定:
   - 期待値
   - 実際の値
   - 失敗したアサーション
3. アサーションから遡って乖離箇所を検出
4. テストのセットアップ/ティアダウンを確認
5. モックが正しいか検証
```

### 「ローカルでは動く」問題のデバッグ

```
1. 環境を比較:
   - ランタイムバージョン
   - 依存関係のバージョン
   - 環境変数
   - データベース/サービスの状態

2. 以下を確認:
   - ハードコードされたパス
   - 欠落した環境変数
   - プラットフォーム固有のコード
```

### パフォーマンスのデバッグ

```
1. 遅い操作を特定
2. タイミング計測を追加
3. プロジェクトにプロファイリングツールがないか確認
4. よくある問題を確認:
   - N+1 クエリ
   - 不要なループ
   - メモリリーク
   - ブロッキング操作
```

---

## ルール（L1 - ハード）

効果的なデバッグと損害回避のために不可欠。

- ALWAYS: 修正を実施する前に根本原因を特定する（誤った修正を防ぐ）
- NEVER: 根本原因分析をスキップしてはならない（表面的な症状は誤誘導する）
- NEVER: 検証なしでコミットしてはならない（さらなるバグを導入する可能性）
- NEVER: リグレッションを無視してはならない（問題が複合化する）
- NEVER: 特定のフレームワークコマンドを仮定してはならない（探索すること）
- MUST: 以下の場合に AskUserQuestion を使用する:
  - 根本原因に複数の解釈がある場合
  - 複数の修正アプローチが利用可能な場合
  - 期待される動作について明確化が必要な場合
  - ユーザーが修正戦略を選択する必要がある場合（TDD vs 直接修正）
- NEVER: どの根本原因が正しいか推測してはならない — ユーザーに確認を求める
- MUST: スペシャリストを選ぶ前に code-explorer に委任してコードドメインを判定する

## デフォルト（L2 - ソフト）

品質の高いデバッグのために重要。適切な理由がある場合はオーバーライド可。

- テスト/ビルドコマンドは実行前に探索する
- テストで修正を検証する
- 実装は適切なスペシャリストに委任する
- 将来の参考のため根本原因分析を文書化する

## ガイドライン（L3）

徹底的なデバッグのための推奨事項。

- consider: TDD アプローチの使用（まず失敗するテストを作成）
- prefer: 調査時に最近の git 変更を確認する
