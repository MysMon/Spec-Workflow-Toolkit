---
description: "承認済み仕様書と設計書に基づいて機能を実装する - ビルド、テスト、レビューを実施"
argument-hint: "[任意: 仕様書ファイルパスまたは機能名]"
allowed-tools: Read, Write, Glob, Grep, Edit, Bash, AskUserQuestion, Task, TodoWrite
---

# /spec-implement - 仕様書ベースの実装

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

承認済みの仕様書と設計書に基づいて機能を実装する。このコマンドはビルドフェーズ（準備、実装、品質レビュー、サマリー）を担当する。

## 前提条件

このコマンドを実行する前に、以下が必要:
- 仕様書ファイル (`docs/specs/[feature-name].md`) - `/spec-plan` で作成
- 設計書 (`docs/specs/[feature-name]-design.md`) - `/spec-plan` で作成
- 任意: レビューレポート (`docs/specs/[feature-name]-review.md`) - `/spec-review` で作成

これらが存在しない場合は、先に `/spec-plan` の実行を提案する。

## 帰属

Anthropic の Effective Harnesses for Long-Running Agents における Initializer + Coding Agent パターンに基づく。

## フェーズ概要

1. **準備** - 仕様書、設計書、レビュー状態を読み込み、整合性を検証
2. **実装** - スペシャリストエージェントで機能を1つずつ構築
3. **品質レビュー** - 並列レビューエージェントが実装を検証
4. **サマリー** - 成果を文書化

## 実行手順

---

## オーケストレーター専用ルール（絶対遵守）

**あなたはオーケストレーターである。自分で作業を行ってはならない。**

詳細なオーケストレーションプロトコルは `subagent-contract` スキルを読み込むこと。

### 絶対禁止事項

1. **大量の Grep/Glob 操作は `code-explorer` に委任すること** - 単発の特定検索のみ直接使用可
2. **大量読み込み（3ファイル超）**: サブエージェントに委任。クイックルックアップ（特定セクションの1-3ファイル）およびフォールバックは許可。
3. **自分でコードを実装してはならない** - `frontend-specialist` または `backend-specialist` に委任
4. **自分でテストを書いてはならない** - `qa-engineer` に委任
5. **自分でセキュリティ分析を行ってはならない** - `security-auditor` に委任

---

### エージェント選択

| エージェント | モデル | 用途 |
|-------|-------|---------|
| `code-explorer` | Sonnet | コードベースの状態を素早く確認 |
| `code-architect` | Sonnet | 必要に応じた設計の明確化 |
| `frontend-specialist` | **inherit** | UI の実装 |
| `backend-specialist` | **inherit** | API の実装 |
| `qa-engineer` | Sonnet | テストと品質レビュー |
| `security-auditor` | Sonnet | セキュリティレビュー（読み取り専用） |
| `verification-specialist` | Sonnet | 参照の検証 |

---

### フェーズ 1: 準備

**目標:** コンテキストを読み込み、実装準備の整合性を検証する。

#### 仕様書と設計書の特定

`$ARGUMENTS` が指定された場合:
- ファイルパスの場合、仕様書ファイルの存在を確認し、対応する設計書を特定（Glob を使用、内容は読まない）
- 機能名の場合、`docs/specs/` で一致するファイルを検索（Glob を使用）

引数なしの場合:
- 進捗ファイルから現在のプロジェクト仕様を確認
- `docs/specs/` の利用可能な仕様書を一覧表示
- どれを実装するかユーザーに確認

#### 前提条件の検証

**読み取りと編集の区別:**
- **コンテキストのための読み取り**: クイックルックアップは許可（`subagent-contract` の「クイックルックアップ定義」を参照）
- **編集・修正**: 必ず適切なエージェントに委任

すべての例外定義（クイックルックアップ制限: 3ファイル以下、200行/ファイル以下、合計300行以下）は `subagent-contract` スキルの「オーケストレーター例外リファレンス」を参照。

**重要: オーケストレーターは仕様書/設計書を直接編集してはならない。**

**存在確認:**
1. **仕様書ファイルの特定** - Glob で `docs/specs/[feature-name].md` の存在を確認
2. **設計書ファイルの特定** - Glob で `docs/specs/[feature-name]-design.md` の存在を確認
3. **レビューレポートの特定** - Glob で `docs/specs/[feature-name]-review.md` の存在を確認
4. **進捗ファイルの特定** - Glob で `.claude/workspaces/{id}/claude-progress.json` の存在を確認

仕様書または設計書が見つからない場合:
```
実装に必要な前提ファイルが不足しています。

仕様書: [あり/なし]
設計書: [あり/なし]

推奨: まず /spec-plan を実行してこれらのファイルを作成してください。
```

**コンテキスト読み込み - 必要に応じて選択:**

**クイックリファレンス（特定セクションの参照）の場合:**
- オーケストレーターは仕様書/設計書を直接読み取り可
- 用途: 単一要件の確認、受け入れ基準の検証、ビルド順序の確認

**包括的コンテキスト（完全な実装準備）の場合:**
`product-manager` エージェントに委任:
```
product-manager エージェントを起動:
タスク: 実装コンテキスト用に仕様書と設計書を要約
入力: 仕様書ファイルパス + 設計書ファイルパス
出力:
- 主要要件サマリー（何を構築するか）
- アーキテクチャサマリー（どう構築するか）
- 設計書からのビルド順序
- 各機能の受け入れ基準
```

**product-manager（コンテキスト読み込み）のエラーハンドリング:**
product-manager が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（ビルド順序と主要要件のみに集中）
2. リトライも失敗した場合は**フォールバック: ファイルを直接読み取り**:
   - 設計書ファイルを直接読み取り、ビルド順序セクションを抽出
   - 仕様書ファイルを直接読み取り、受け入れ基準セクションを抽出
   - 抽出した内容を実装コンテキストとして使用
   - ユーザーに警告: 「直接ファイル読み取りを使用（要約処理に失敗）」
3. 進捗ファイルに追加: `"warnings": ["Context loading via agent failed, using direct read fallback"]`
4. 利用可能なコンテキストで続行（実装全体をブロックしない）

**重要: 進行前にコンテキストサマリーをユーザーに提示すること:**

product-manager の完了後（またはフォールバック完了後）、実装コンテキストをユーザーに提示:

```markdown
## 実装コンテキストサマリー

### 構築内容
[product-manager の出力からの主要要件]

### 構築方法
[product-manager の出力からのアーキテクチャサマリー]

### ビルド順序
1. [機能 1]
2. [機能 2]
...

### 受け入れ基準
- [基準 1]
- [基準 2]
...
```

AskUserQuestion で理解の確認:
```
Question: "仕様書からの理解は以上です。この内容で正しいですか？"
Header: "コンテキスト確認"
Options:
- "はい、正しいです"
- "一部正しいが、補足があります"
- "間違っています、要件を再説明します"
```

ユーザーが「一部正しい」または「間違っている」を選択した場合は、進行前に補足を収集する。

#### レビュー対応ハンドオフ

**進捗ファイルの読み取りが許容される理由（委任不要）:**
- 進捗ファイルはオーケストレーターの状態メタデータ（プロジェクトコンテンツではない）
- レビュー状態の確認はクイックバリデーション（通常 JSON 20行未満）
- ユーザーレビューが完了したかを判断するために不可欠
- 仕様書/設計書のコンテンツ分析と比較してコンテキスト消費が最小
- resume.md フェーズ 3 のパターンと一貫

進捗ファイルでレビュー状態を確認:

| 進捗フェーズ | 意味 | アクション |
|----------------|---------|--------|
| `plan-complete` | ユーザーレビューがスキップされた | 警告: 「ユーザーレビューが実行されていません。先に `/spec-review` の実行を検討してください。」ユーザーが確認すれば続行。 |
| `review-complete` + APPROVED | ユーザーがレビューして承認済み | 通常通り続行。レビュー中に適用された変更を記録。 |

レビューログファイル (`docs/specs/[feature-name]-review.md`) が存在する場合は、`product-manager` エージェントに委任してレビュー中の変更を要約する。レビューログ全体を直接読み取らないこと。

#### 進捗の初期化または再開

**新規開始（実装進捗なし）の場合:**
product-manager エージェントのビルド順序出力（上記の前提条件検証ステップで取得）から `feature-list.json` を作成する。設計書を直接読み取らないこと。

進捗ファイルを更新:
- currentPhase: "impl-starting"
- currentTask: "Beginning implementation"

**進捗ファイルが実装中を示している場合:**
最後の未完了機能から再開する。

**重要 (L1): 実装開始前にユーザーの明示的な承認を得ること。**

AskUserQuestion を使用:
```
Question: "実装を開始してよろしいですか？コードベースのファイルが変更されます。"
Header: "確認"
Options:
- "はい、実装を進めてください"
- "いいえ、先に計画を確認させてください"
- "ビルド順序をもう一度見せてください"
```

**明示的な「はい」の確認なしに進行してはならない。**

---

### フェーズ 2: 実装

**目標:** 仕様書と設計書に従って機能を構築する。

Initializer + Coding パターンのために `long-running-tasks` スキルを読み込むこと。

#### 重要: 一度に1つの機能

1. `feature-list.json` から次の未完了機能を特定
2. スペシャリストエージェントに実装を委任
3. 完了を待機
4. テストを実行（`qa-engineer` に委任）
5. 進捗ファイルを更新（`claude-progress.json`、`feature-list.json`）
6. 説明的なメッセージでワーキングコードをコミット
7. 次の機能へ

**現在の機能が以下を満たすまで次の機能に進んではならない:**
- 実装完了
- テスト完了
- コミット完了
- 進捗ファイル更新完了

#### 実装パターンの選択

| 条件 | パターン | ワークフロー |
|-----------|---------|----------|
| 明確な受け入れ基準がある | **TDD** | qa-engineer が失敗テストを作成 → スペシャリストが実装 → リファクタリング |
| 探索的、UI 中心 | **スタンダード** | スペシャリストが実装 → qa-engineer が検証 → 反復 |
| 再現手順のあるバグ修正 | **TDD** | qa-engineer が失敗テストを作成 → スペシャリストが修正 |

**TDD パターン**（`tdd-workflow` スキルを読み込み）:
- RED: `qa-engineer` が受け入れ基準に基づいて失敗テストを作成
- GREEN: スペシャリストがテストを通す最小限のコードを実装
- REFACTOR: レビューとクリーンアップ

**スタンダードパターン**:
- スペシャリストが機能を実装
- `qa-engineer` が検証してテストを作成
- フィードバックに基づいて反復

#### スペシャリストエージェントへの委任

注: `frontend-specialist` と `backend-specialist` は `model: inherit` を使用するため、ユーザーのセッションで実行中のモデルが使われる。

フロントエンド作業の場合:
```
frontend-specialist エージェントを起動して実装: [コンポーネント/機能]
仕様書に従う: docs/specs/[feature-name].md
設計書に従う: docs/specs/[feature-name]-design.md
設計書からの主要ファイル: [Implementation Map エントリ]
TDD モード: [はい/いいえ] - はいの場合、テストファイルを参照
期待出力: テスト付きの動作するコンポーネント
```

バックエンド作業の場合:
```
backend-specialist エージェントを起動して実装: [サービス/API]
仕様書に従う: docs/specs/[feature-name].md
設計書に従う: docs/specs/[feature-name]-design.md
設計書からの主要ファイル: [Implementation Map エントリ]
TDD モード: [はい/いいえ] - はいの場合、テストファイルを参照
期待出力: テスト付きの動作するサービス
```

**各スペシャリストエージェント完了後:**
1. エージェントの出力サマリーを確認
2. 再開の可能性に備えてエージェント ID を記録
3. `feature-list.json` を更新（機能を完了としてマーク）
4. `claude-progress.json` を更新（currentTask、nextAction を更新）
5. TodoWrite で可視的な進捗を更新
6. AskUserQuestion でコミット前にレビューしたいか確認:
   ```
   Question: "機能の実装が完了しました。コミット前にレビューしますか？"
   Header: "レビュー"
   Options:
   - "変更内容を確認させてください"
   - "コミットを進めてください"
   - "判断前にテストを実行してください"
   ```

**スペシャリストエージェント（frontend-specialist、backend-specialist）のエラーハンドリング:**

スペシャリストエージェントが失敗またはタイムアウトした場合:
1. エージェントの部分出力で使用可能なコード/進捗を確認
2. スコープを縮小してリトライ（単一コンポーネント/関数に集中）
3. リトライも失敗した場合:
   - **重要: 実装が部分的な場合、機能を完了としてマークしない**
   - `feature-list.json` のステータスを `"blocked"` に更新（理由を記載）
   - ユーザーに提示:
     ```
     [機能] の実装で問題が発生しました。

     エージェント出力: [実施内容のサマリー（あれば）]
     エラー: [失敗理由]

     オプション:
     1. スコープを簡略化してリトライ（単一コンポーネントに集中）
     2. 部分的な実装をレビューして手動で完了
     3. この機能をスキップして次へ進む
     4. /debug にエスカレーションして調査
     ```
   - 進捗ファイルに障害を記録: `"warnings": ["Feature X implementation failed: [reason]"]`
4. ユーザーがオプションを選択してから続行

#### 反復作業のためのサブエージェント再開

| シナリオ | アクション |
|----------|--------|
| 同一機能のスコープ拡大 | 再開 |
| パーミッションエラーからの復旧 | フォアグラウンドで再開 |
| 完全に異なる機能 | 新しいエージェント |
| エージェントがコンテキスト上限に到達 | サマリー付きの新しいエージェント |

#### 仕様と現実の乖離への対応

実装中に、スペシャリストエージェントまたはあなたが仕様書/設計書と現実の不一致を発見することがある（例: 想定していた API が存在しない、パターンが期待と異なる動作をする等）。

**乖離が軽微な場合**（実装の詳細レベル、仕様レベルではない）:
- 実装を適応させ、逸脱を記録
- 進捗ログに追加: `"deviation": "Adapted X because Y"`

**乖離が重大な場合**（仕様要件と矛盾する）:
1. 現在の機能の実装を停止
2. ユーザーに問題を提示:
   ```
   実装中に仕様と現実の不一致が見つかりました:

   仕様では: [仕様が前提としている内容]
   実際には: [実際に見つかった内容]
   影響: [計画への影響]

   オプション:
   1. 設計を適応 → この機能のみアプローチを調整します
   2. 仕様書と設計書を更新 → 実装を一時停止し、ドキュメントを更新
   3. 計画に戻る → 新しい知見で /spec-plan を再実行
   ```
3. ユーザーの選択に基づいて続行

---

### フェーズ 3: 品質レビュー

**目標:** コードが品質、セキュリティ、仕様要件を満たしていることを確認する。

**4つの並列レビューエージェント（Sonnet）を起動:**

```
以下のレビューエージェントを並列で起動:

1. qa-engineer エージェント
   フォーカス: テストカバレッジ、エッジケース、受け入れ基準
   信頼度閾値: 80
   出力: テストギャップ、品質問題（file:line 付き）

2. security-auditor エージェント
   フォーカス: OWASP Top 10、認証/認可、データバリデーション
   信頼度閾値: 80
   出力: 脆弱性（file:line と修正方法付き）

3. code-explorer エージェント（検証）
   フォーカス: 実装が設計仕様と一致しているか検証
   徹底度: quick
   比較: 実装 vs docs/specs/[feature]-design.md
   出力: 逸脱、不足部分（file:line 付き）

4. verification-specialist エージェント
   フォーカス: 他のエージェントからの file:line 参照を検証
   タスク: 発見事項の正確性をクロスチェック
   出力: 検証レポート（VERIFIED/PARTIAL/UNVERIFIED ステータス付き）
```

**全エージェントの完了を待機。**

**エラーハンドリング:**

**重要: security-auditor の失敗は致命的（L1 ルール）:**
security-auditor が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（クリティカルパスのみに集中）
2. リトライも失敗した場合: **停止してユーザーに通知**
   ```
   セキュリティレビューが失敗しました。セキュリティバリデーションなしには続行できません。

   オプション:
   1. 手動スコープ選択でセキュリティレビューをリトライ
   2. セキュリティレビューをスキップ（非推奨 - ユーザーの明示的な承認が必要）
   3. 中断して障害を調査
   ```
3. セキュリティレビューが通過するか、ユーザーが明示的にスキップを承認するまで実装を進めない

**その他のエージェント（qa-engineer、code-explorer、verification-specialist）:**
エージェントが失敗またはタイムアウトした場合:
1. エージェントの部分出力で使用可能な発見事項を確認
2. スコープを縮小してリトライ
3. リトライも失敗した場合、利用可能な結果で続行しギャップを記録
4. 進捗ファイルに追加: `"warnings": ["Agent X failed, results may be incomplete"]`

#### ファイル参照のクロスバリデーション

スコアリング前に verification-specialist のレポートをレビュー:

| 検証ステータス | アクション |
|---------------------|--------|
| VERIFIED | 発見事項をそのまま保持 |
| PARTIAL | 信頼度を 10 減算 |
| UNVERIFIED | 信頼度を 20 減算、`"verified": false` としてフラグ |

**信頼度加重で発見事項を統合:**

| シナリオ | アクション |
|----------|--------|
| スコア < 80 | フィルタアウト |
| 1エージェントが報告（80以上） | そのまま報告 |
| 2エージェントが一致 | 信頼度をブースト |
| 3エージェントが一致 | 確認済みとして扱う |

**発見事項をユーザーに提示:**
```markdown
## 品質レビュー結果

### クリティカルな問題（信頼度 >= 90）
1. **[問題タイトル]** - [カテゴリ]（スコア: [N]、検証済み: [はい/いいえ]）
   ファイル: `file:line`
   **修正:** [修正方法]

### 重要な問題（信頼度 80-89）
...

### サマリー
- クリティカル: [N]
- 重要: [N]
- フィルタ済み（80未満）: [N]

**判定:** [承認 / 要変更]
```

**ユーザーに確認:** 「[N] 件の問題が見つかりました。どうしますか？」
1. クリティカルな問題のみ修正
2. すべての問題を修正
3. 変更なしで続行
4. 特定の問題の詳細を確認

#### 評価・最適化ループ（クリティカルな問題がある場合）

クリティカルな問題が見つかり、ユーザーが修正を選択した場合:

```
反復ループ（最大3回）:

1. ジェネレーター: スペシャリストエージェントに修正を委任
2. 評価者: 元のレビューアーに再チェックを委任
3. スコア >= 80 の場合: 受理。< 80 の場合: ループ。最大到達の場合: ユーザーにエスカレーション。
```

詳細なパターンは `skills/workflows/evaluator-optimizer/SKILL.md` を参照。

**進捗更新:**
`claude-progress.json` を更新:
- currentPhase: "impl-review-complete"
- resumptionContext.nextAction: "Proceed to Summary"

---

### フェーズ 4: サマリー

**目標:** 成果を文書化する。

**進捗ファイルを完了ステータスに更新。**

```markdown
## 実装完了

### 構築した内容
- [機能の説明]

### 主要な決定事項
- [決定 1]: [根拠]

### 設計からの逸脱
- [逸脱 1]: [理由と適応内容]

### 変更ファイル
| ファイル | 変更内容 |
|------|---------|
| `path/to/file.ts` | [サマリー] |

### 品質ステータス
- テスト: [通過/失敗]
- セキュリティ: [承認/問題あり]
- カバレッジ: [パーセンテージ]

### 次のステップ
1. [推奨フォローアップ 1]
2. [推奨フォローアップ 2]
```

**すべての TODO を完了にマーク。**

## 使用例

```bash
# 仕様書ファイルから実装
/spec-implement docs/specs/user-authentication.md

# 機能名で実装
/spec-implement user-authentication

# 実装を再開（進捗ファイルから自動検出）
/spec-implement
```

## 使うべきでない場合

- 仕様書や設計書が存在しない場合（先に `/spec-plan` を実行）
- 1行のバグ修正（直接修正する）
- 些細な変更（`/quick-impl` を使用）
- 緊急ホットフィックス（`/hotfix` を使用）

---

## ルール（L1 - ハード）

安全な実装とオーケストレーションに不可欠。

- MUST: 大量の Grep/Glob 操作は `code-explorer` に委任する（単発の特定検索のみ直接使用可）
- MUST: 大量読み込み（3ファイル超）はサブエージェントに委任する。クイックルックアップおよびフォールバックは許可。
- NEVER: 自分でコードを実装する — `frontend-specialist` または `backend-specialist` に委任
- NEVER: 自分でテストを書く — `qa-engineer` に委任
- NEVER: 自分でセキュリティ分析を行う — `security-auditor` に委任
- MUST: ファイル変更前にユーザーの明示的な承認を得る
- NEVER: ユーザーの確認なしに実装を進める
- MUST: 以下の場合は AskUserQuestion を使用する:
  - 仕様と現実の乖離が発見された場合
  - 複数の実装アプローチが可能な場合
  - 品質レビュー中にユーザーのフィードバックが曖昧な場合
- NEVER: `security-auditor` エージェントが失敗した場合、ユーザーの明示的な承認なしに続行する — セキュリティレビューのスキップにはユーザーの文書化された同意が必要
- MUST: エージェントがタイムアウトした場合、スコープを縮小して1回リトライする
- MUST: 続行前にすべてのエージェント障害を進捗ファイルに記録する
- MUST: 各機能完了後に進捗ファイルを更新する

## デフォルト（L2 - ソフト）

品質の高い実装に重要。適切な理由がある場合はオーバーライド可。

- 一度に1つの機能を完了（実装 → テスト → コミット → 次へ）
- 明確な受け入れ基準がある場合は TDD パターンを使用
- フェーズ 3 で4つの並列レビューエージェントを起動
- 複数エージェントからの問題を重複排除（信頼度を 10 ブースト）

## ガイドライン（L3）

効果的な実装のための推奨事項。

- consider: 各機能のコミット前にユーザーにレビューしたいか確認する
- recommend: 品質レビューの発見事項は重要度別にグループ化して提示する
- consider: 設計からの逸脱は将来の参考のために文書化する
