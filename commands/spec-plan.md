---
description: "仕様書ファーストの方法論で機能を計画する - 発見、探索、明確化、アーキテクチャ設計を反復的改善で実施"
argument-hint: "[任意: 機能の説明]"
allowed-tools: Read, Write, Glob, Grep, Edit, Bash, AskUserQuestion, Task, TodoWrite
---

# /spec-plan - 仕様書ファーストの計画

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

4つのフェーズを通じて、各ゲートで反復的改善を行いながら機能を計画する。`/spec-review` と `/spec-implement` に備えた仕様書と設計書を生成する。

## 帰属

公式の feature-dev プラグイン、Claude Code Best Practices、Effective Harnesses for Long-Running Agents、Building Effective Agents（6 Composable Patterns）に基づく。

## 計画と実装を分離する理由

Anthropic の「Effective Harnesses for Long-Running Agents」では、エージェントが複雑な作業を「ワンショットで試みると不十分」になることが判明した。解決策: **イニシャライザー**（計画）フェーズをインクリメンタルな**コーディング**セッションから分離する。

利点:
- 計画にフルコンテキストウィンドウを使用可能（実装アーティファクトによるトークン消費なし）
- コストのかかる実装前にヒューマンレビューの自然なチェックポイント
- `/spec-review` で計画と実装の間にプランを検証可能
- Claude Code 開発者のワークフロー: 「Plan Mode → プランの改善 → 自動承認で実装」

## フェーズ概要

1. **発見** - 何を構築すべきかを理解する
2. **コードベース探索** - 既存のコードとパターンを理解する（並列エージェント）
3. **仕様書作成** - ギャップを埋め、曖昧さを解消し、仕様を起草して改善
4. **アーキテクチャ設計** - 複数の角度から分析し、1つのアプローチに統合して改善

各フェーズのユーザーインタラクションには**改善ループ**が含まれる — 単純な承認/却下ではなく、ユーザーフィードバックに基づく反復的な修正。

## 実行手順

---

## オーケストレーター専用ルール（絶対遵守）

**あなたはオーケストレーターである。自分で作業を行ってはならない。**

詳細なオーケストレーションプロトコルは `subagent-contract` スキルを読み込むこと。

### 絶対禁止事項

1. **大量の Grep/Glob 操作は `code-explorer` に委任すること** - 単発の特定検索のみ直接使用可
2. **大量読み込み（3ファイル超）**: サブエージェントに委任。クイックルックアップ（特定セクションの1-3ファイル）は許可。
3. **自分でコードを実装してはならない** - これは計画コマンド
4. **実装に飛んではならない** - 出力は計画であり、コードではない

### あなたの唯一の責務

1. **オーケストレート** - サブエージェントの起動と調整
2. **統合** - サブエージェント出力を一貫したサマリーに統合
3. **コミュニケーション** - 発見事項を提示し、ユーザーに質問
4. **進捗管理** - TodoWrite と進捗ファイルの更新
5. **特定ファイルの読み取り** - サブエージェントが特定したファイルのみ（一度に最大3つ）

---

### エージェント選択

| エージェント | モデル | 用途 |
|-------|-------|---------|
| `code-explorer` | Sonnet | 深いコードベース分析（4フェーズ探索） |
| ビルトイン `Explore` | Haiku | クイックルックアップと簡単な検索 |
| `code-architect` | Sonnet | 機能レベルの実装ブループリント |
| `product-manager` | Opus | 仕様書作成（高品質 PRD） |
| `verification-specialist` | Sonnet | 参照の検証 |

---

### フェーズ 1: 発見

**目標:** 何を構築すべきか、その理由を理解する。

#### 重要: 既存の進捗を確認（L1 - 最初に必ず実行）

**新しい進捗ファイルを作成する前に、このプロジェクトの作業が既に存在するか確認する。**

**進捗ファイルの読み取りが許容される理由（委任不要）:**
進捗ファイルはオーケストレーターの状態メタデータであり、プロジェクトコンテンツではない。Progress/Metadata Read 例外の完全な正当性は `subagent-contract` スキルの「オーケストレーター例外リファレンス」を参照。

1. **既存の進捗ファイルを確認:**
   - ワークスペース ID を生成: `{branch}_{path-hash}`（SessionStart フックコンテキストから）
   - `.claude/workspaces/{workspace-id}/claude-progress.json` を探す

2. **進捗ファイルが存在し、ステータスが "completed" でない場合:**
   ```
   既存の進捗を検出

   プロジェクト: [進捗ファイルからのプロジェクト名]
   現在のフェーズ: [進捗ファイルからの currentPhase]
   最終更新: [進捗ファイルからの lastUpdated]
   ステータス: [進捗ファイルからの status]

   オプション:
   1. 既存の作業を継続 → /resume コマンドを使用
   2. 新規開始 → 既存の進捗はアーカイブされます
   3. キャンセル → 何もしない

   どうしますか？
   ```

3. **ユーザーが「新規開始」を選択した場合:**
   - アーカイブディレクトリを作成: `.claude/workspaces/{id}/archived/{YYYY-MM-DD_HH-MM-SS}/`
   - すべての進捗ファイルをアーカイブディレクトリに移動:
     - `claude-progress.json` → `archived/{timestamp}/claude-progress.json`
     - `feature-list.json` → `archived/{timestamp}/feature-list.json`
   - この形式は `/resume` コマンドのアーカイブ規約と一致
   - 新しい進捗ファイルの作成に進む

4. **進捗ファイルが存在しない、またはステータスが "completed" の場合:**
   - 進捗ファイルの初期化に直接進む

#### 重要: 進捗ファイルの初期化（L1 - 確認後に必ず実行）

**このステップをスキップしてはならない。フェーズ 1 の他の作業の前に進捗ファイルを作成すること。**

1. **ワークスペース ID の生成**: `{branch}_{path-hash}` 形式を使用（SessionStart フックコンテキストから）
2. **ディレクトリの作成**: `.claude/workspaces/{workspace-id}/`
3. **進捗ファイルの作成**: `.claude/workspaces/{workspace-id}/claude-progress.json`

**初期進捗ファイル構造:**
```json
{
  "workspaceId": "{generated-workspace-id}",
  "project": "{project-name}",
  "started": "{ISO-8601-timestamp}",
  "lastUpdated": "{ISO-8601-timestamp}",
  "status": "in_progress",
  "currentPhase": "plan-discovery",
  "currentTask": "Discovery - gathering requirements",
  "sessions": [],
  "log": [],
  "resumptionContext": {
    "position": "Phase 1: Discovery",
    "nextAction": "Complete requirements gathering and user interview",
    "dependencies": [],
    "blockers": []
  }
}
```

**注:** Write ツールの成功でファイル作成が確認される。追加の検証は不要。

#### 発見作業

ユーザーが機能の説明を提供した場合（`$ARGUMENTS`）、提供されたテキストのみに基づいて**簡易明確度評価**を実行:

**「簡易明確度評価」の意味:**
- ユーザーの入力文字列のみを確認（ファイル読み取りなし、コードベース探索なし）
- 基本情報の有無を確認
- 数秒で完了（分単位ではない）— 引数の純粋なテキスト分析

**以下の3つの基準を評価:**
1. **問題文:** テキストだけから解決すべき問題を理解できるか？
2. **対象ユーザー:** 対象ユーザーが言及されている、または推測可能か？
3. **制約:** 明確なスコープ制限や要件が記載されているか？

**次のアクション:**
- 3つすべて明確な場合: AskUserQuestion で理解を確認
- 1つ以上不明確な場合: 進行前に AskUserQuestion でギャップを埋める

**重要:** この時点ではファイルの読み取りやコードベースの探索を行わない。コードベース探索は要件理解後のフェーズ 2 で実施。

**重要: リクエストが曖昧または不明確な場合は AskUserQuestion を使用すること。**

リクエストが曖昧または不足している場合:
1. **AskUserQuestion を使用**して明確化:
   - どの問題を解決するのか？
   - 対象ユーザーは誰か？
   - 成功とは何か？
2. ステークホルダーとユースケースを特定
3. 初期理解を文書化

AskUserQuestion のトリガー例:
| ユーザーの発言 | 確認すべき内容 |
|-----------|-----------|
| 「機能を追加して」 | どの機能？誰のため？なぜ？ |
| 「パフォーマンスを改善して」 | どの操作？目標は？ |
| 「もっと良くして」 | どう良くする？速く？簡単に？信頼性高く？ |

**ドメイン知識の注入:** ユーザーに確認:
```
コードベースを探索する前に、知っておくべきコンテキストはありますか？
- 内部設計ガイドラインや規約？
- 参考にすべきリファレンス実装？
- コードからは見えない制約？

（なければスキップ）
```

**出力:** 理解のサマリーとユーザーからの確認。

**進捗更新:** currentPhase: "plan-discovery-complete"

---

### フェーズ 2: コードベース探索

**目標:** 関連する既存コードとパターンを理解する。

**2-3体の `code-explorer` エージェントを並列起動:**

```
以下の code-explorer エージェントを並列で起動:

1. code-explorer（類似機能）
   タスク: 類似機能の既存実装を探索
   徹底度: medium
   出力: エントリーポイント、実行フロー、主要ファイル

2. code-explorer（アーキテクチャ）
   タスク: 全体アーキテクチャと使用パターンをマッピング
   徹底度: medium
   出力: レイヤー、境界、規約

3. code-explorer（UI パターン）- フロントエンド作業がある場合
   タスク: UI コンポーネントパターンと状態管理をトレース
   徹底度: medium
   出力: コンポーネント階層、データフロー
```

**全エージェントの完了を待機。**

**エラーハンドリング:**
エージェントが失敗またはタイムアウトした場合:
1. エージェントの部分出力で使用可能な発見事項を確認
2. 重要なエージェントが失敗した場合、スコープを縮小してリトライ
3. リトライも失敗した場合、利用可能な結果で続行しギャップを記録
4. 進捗ファイルに追加: `"warnings": ["Agent X failed, results may be incomplete"]`

**重要: 探索後にファイルを直接読み取らないこと。エージェントの出力を使用する。**

`code-explorer` エージェントが既にファイルを読み取り要約している。その出力を直接使用すること。

明確化のために特定のファイルの詳細が必要な場合は、`code-explorer` に集中的なクエリで委任する。

#### 複数エージェント出力の統合

すべての code-explorer エージェントが完了したら、発見事項を以下のように統合:

1. **カテゴリ別に統合:**
   - エントリーポイントと実行フロー（類似機能エージェントから）
   - アーキテクチャパターンと規約（アーキテクチャエージェントから）
   - UI パターンとデータフロー（UI パターンエージェントから、該当する場合）

2. **重複の特定:** 複数のエージェントが同じファイルやパターンに言及している場合、高関連度として記録

3. **構造化サマリーの作成:**
   ```markdown
   ## コードベース探索サマリー

   ### 主要ファイル
   - [ファイルパス]: [関連性]（報告元: [エージェント名]）

   ### 特定されたパターン
   - [パターン]: [説明]

   ### 発見された制約
   - [制約]: [設計への影響]
   ```

4. **フェーズ 3 へ渡す:** この統合サマリーを product-manager の仕様書作成の入力として使用

**発見事項の包括的サマリーをユーザーに提示（エージェント出力を使用）。**

**進捗更新:** currentPhase: "plan-exploration-complete"

---

### フェーズ 3: 仕様書作成

**目標:** ギャップを埋め、曖昧さを解消し、仕様書を起草して改善する。

発見と探索に基づいて、以下を特定:
- エッジケース
- エラーハンドリング要件
- 統合ポイント
- 後方互換性の必要性
- パフォーマンス要件

**AskUserQuestion で明確化質問を行う。**

**重要: ユーザーの回答を待ってから進行すること。**

**仕様書の起草:**

**重要: すべての仕様書作業は `product-manager` エージェントに委任すること。**

既存の仕様書の確認・更新であれ、新規作成であれ、`product-manager` に委任する。

```
product-manager エージェントを起動して仕様書を起草:
仕様書ターゲット: docs/specs/[feature-name].md
テンプレート: docs/specs/SPEC-TEMPLATE.md
入力: 明確化された要件 + 探索の発見事項 + ユーザーのドメイン知識
出力: ユーザーレビュー用のドラフト仕様書
```

**product-manager のエラーハンドリング:**
product-manager が失敗またはタイムアウトした場合:
1. エージェントの部分出力で使用可能なドラフト内容を確認
2. スコープを縮小してリトライ（コア要件のみに集中）
3. リトライも失敗した場合、ユーザーに通知しオプションを提示:
   - 「部分的な仕様書で続行し、手動で改善」
   - 「簡略化した要件でリトライ」
   - 「キャンセルして障害を調査」
4. 進捗ファイルに追加: `"warnings": ["product-manager failed, spec may be incomplete"]`

#### 仕様書改善ループ（最大3回反復）

ドラフト仕様書をユーザーに提示して確認:

```
ドラフト仕様書ができました。レビューしてください。

オプション:
1. このまま承認 → アーキテクチャ設計に進む
2. 変更を依頼 → 修正箇所を教えてください（修正して再提示します）
3. 要件を追加 → 追加のコンテキストや制約を提供してください
4. 却下して再開 → 要件の再収集
```

**ユーザーが変更を依頼した場合（オプション 2 または 3）:**
1. ユーザーのフィードバックを反映
2. 更新された入力で `product-manager` を再起動して仕様書を修正
3. 修正された仕様書を提示（エージェント出力を使用）
4. 承認されるか最大3回の反復に達するまで繰り返す

**重要:** 仕様書の修正は常に `product-manager` に委任する。仕様書ファイルを直接編集しないこと。

**最大反復に達しても承認されない場合:**
ユーザーに確認: 「3回反復しました。現在のバージョンを承認するか、手動で改善を続けるか、最初からやり直しますか？」

**出力:** `docs/specs/[feature-name].md` に承認済み仕様書

**進捗更新:** currentPhase: "plan-spec-approved"

---

### フェーズ 4: アーキテクチャ設計

**目標:** コードベースのパターンと承認済み仕様書に基づいて実装アプローチを設計する。

**2-3体の `code-architect` エージェントを異なる分析フォーカスで並列起動:**

```
以下の code-architect エージェントを並列で起動:

1. code-architect（再利用分析）
   分析: 既存パターンとコードの再利用方法
   コンテキスト: [探索の発見事項]、[承認済み仕様書]
   出力: file:line エビデンス付きの再利用機会

2. code-architect（拡張性分析）
   分析: 将来の成長に向けたクリーンな抽象化機会
   コンテキスト: [探索の発見事項]、[承認済み仕様書]
   出力: file:line エビデンス付きの抽象化推奨

3. code-architect（パフォーマンス分析）- 関連する場合
   分析: パフォーマンスへの影響と最適化
   コンテキスト: [探索の発見事項]、[承認済み仕様書]
   出力: file:line エビデンス付きのパフォーマンス考慮事項
```

**全エージェントの完了を待機。**

**code-architect エージェントのエラーハンドリング:**
code-architect エージェントが失敗またはタイムアウトした場合:
1. エージェントの部分出力で使用可能な分析を確認
2. 重要な分析（再利用分析）が失敗した場合、スコープを縮小してリトライ
3. 重要でない分析（パフォーマンス）が失敗した場合、利用可能な結果で続行
4. 進捗ファイルに追加: `"warnings": ["code-architect [type] failed, design may be incomplete"]`

**設計の統合を product-manager エージェントに委任:**

```
product-manager エージェントを起動:
タスク: code-architect の出力を1つの設計書に統合
入力:
- code-architect #1 の再利用分析出力
- code-architect #2 の拡張性分析出力
- code-architect #3 のパフォーマンス分析出力（該当する場合）
- 承認済み仕様書ファイルパス
テンプレートセクション:
- コードベースからのパターン分析（file:line 参照付き）
- 推奨アプローチ（アーキテクチャサマリー、根拠）
- 実装マップ（コンポーネント → ファイル → アクション）
- ビルド順序（順序付きタスク）
- 考慮されたトレードオフ
- 却下されたアプローチ
出力: ドラフト設計書の内容
```

設計書にはエージェントの出力を使用する。手動で統合しないこと。

**設計統合のエラーハンドリング:**
統合中に product-manager が失敗した場合:
1. 部分出力で使用可能な設計要素を確認
2. 要約された code-architect 出力でリトライ
3. リトライも失敗した場合、ユーザーに通知しオプションを提示:
   - 「利用可能な code-architect 出力を直接使用（統合度は低い）」
   - 「簡略化した入力で統合をリトライ」
   - 「キャンセルして調査」
4. 進捗ファイルに追加: `"warnings": ["design synthesis failed"]`

#### アーキテクチャ改善ループ（最大3回反復）

設計をユーザーに提示して確認:

```
アーキテクチャ案ができました。レビューしてください。

オプション:
1. 承認 → 設計を保存して計画を完了
2. 変更を依頼 → 修正箇所を教えてください（例: 「JWT ではなくセッションベース認証を使用」）
3. 代替案を探索 → 異なる制約で再分析
4. 仕様書に戻る → まず仕様書を修正
```

**ユーザーが変更を依頼した場合（オプション 2）:**
1. 更新された制約で関連する `code-architect` エージェントを再起動
2. 更新された code-architect 出力で product-manager に設計修正を委任
3. 修正された設計を提示（エージェント出力を使用）
4. 承認されるか最大3回の反復に達するまで繰り返す

**ユーザーが代替案の探索を希望した場合（オプション 3）:**
1. 代替アプローチで `code-architect` を起動
2. オリジナル vs 代替案のトレードオフを比較提示
3. ユーザーに選択させる

**ユーザーが仕様書に戻りたい場合（オプション 4）:**
1. フェーズ 3 の仕様書改善ループに戻る
2. 仕様書が再承認された後、フェーズ 4 を再実行

**出力:** `docs/specs/[feature-name]-design.md` に承認済み設計を保存

---

### セルフレビューゲート

**フェーズ 4 の設計が承認された後、最終出力を提示する前にセルフレビューゲートを実行する。**

**`verification-specialist` エージェントに委任:**

```
verification-specialist エージェントを起動:
タスク: 13項目のセルフレビューチェックリストを実行
スキル: plan-self-review
入力: 仕様書ファイルパス + 設計書ファイルパス
出力: パス/フラグステータス付きのチェックリスト結果
```

**verification-specialist（セルフレビュー）のエラーハンドリング:**
verification-specialist が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（重要なチェックリスト項目に集中: 要件カバレッジ、ファイル参照、ビルド順序）
2. リトライも失敗した場合、ユーザーに通知:
   ```
   セルフレビューチェックを完了できませんでした。

   オプション:
   1. セルフレビューなしでプランを提示（手動レビュー推奨）
   2. セルフレビューをリトライ
   3. キャンセルして障害を調査
   ```
3. ユーザーがオプション 1 を選択した場合: 「セルフレビュー未完了」の警告付きでプランを提示
4. 進捗ファイルに追加: `"warnings": ["Self-review failed, manual review recommended"]`

**セルフレビュー結果に基づくアクション:**

verification-specialist は PASS または FLAG でマークされた項目を含むチェックリストを返す。FLAG の合計数をカウント:

| 結果 | アクション |
|--------|--------|
| ALL CLEAR（0 フラグ） | プランをそのままユーザーに提示 |
| MINOR FLAGS（1-2 フラグ） | フラグを記載してプランを提示。許容するかはユーザーが判断 |
| NEEDS ATTENTION（3以上のフラグ） | product-manager に修正を委任し、チェックリストを1回再実行してから提示 |

**注:** フラグは verification-specialist が13項目のチェックリスト（`plan-self-review` スキル参照）で不完全または不整合としてマークした項目。

ユーザーが確認内容を把握できるよう、最終出力にセルフレビュー結果を含める。

---

**進捗更新:**
`claude-progress.json` を更新:
- currentPhase: "plan-complete"
- currentTask: "Planning complete - ready for user review"
- resumptionContext.nextAction: "Run /spec-review for user feedback, then /spec-implement"

## 計画完了 - 次のステップ

セルフレビューゲート後に提示:

```markdown
## 計画完了

### 出力
- 仕様書: `docs/specs/[feature-name].md`
- 設計書: `docs/specs/[feature-name]-design.md`
- 進捗: `.claude/workspaces/{id}/claude-progress.json`

### セルフレビュー
[ALL CLEAR / MINOR FLAGS / 結果サマリー]

### 次のステップ
`/spec-review docs/specs/[feature-name].md` を実行して
プランをインタラクティブにレビュー — フィードバック、変更依頼、承認が可能。
その後 `/spec-implement` を実行して構築。
```

## 使用例

```bash
# 機能の計画を開始
/spec-plan OAuth 対応のユーザー認証を追加

# インタラクティブに開始
/spec-plan

# 既存の要件から計画
/spec-plan docs/specs/user-dashboard.md に記載された機能を実装
```

## 使うべきでない場合

- 1行のバグ修正（直接修正する）
- スコープが明確な些細な変更（`/quick-impl` を使用）
- 緊急ホットフィックス（`/hotfix` を使用）
- 承認済み仕様書がある場合（直接 `/spec-implement` へ）

---

## ルール（L1 - ハード）

オーケストレーションと計画品質に不可欠。

- MUST: 大量の Grep/Glob 操作は `code-explorer` に委任する（単発の特定検索のみ直接使用可）
- MUST: 大量読み込み（3ファイル超）はサブエージェントに委任する（1-3ファイルのクイックルックアップは許可）
- NEVER: 自分でコードを実装する — これは計画コマンド
- NEVER: 実装に飛ぶ — 出力は計画であり、コードではない
- NEVER: 仕様書にコードスニペットを含める — 仕様書は「何を」を定義し、「どうやって」は定義しない
- NEVER: 仕様書に擬似コード、関数シグネチャ、アルゴリズム詳細を含める
- ALWAYS: コードのコピーではなく file:line 参照を使用する（例: 「`src/auth.ts:23` のパターンに従う」）
- MUST: 以下の場合は AskUserQuestion を使用する:
  - ユーザーのリクエストが曖昧、または重要な詳細が不足
  - 要件の解釈が複数可能
  - 次のフェーズに進む前に明確化が必要
  - 改善ループ中のユーザーフィードバックが曖昧
- NEVER: ユーザーの意図を推測する — まず AskUserQuestion で確認
- MUST: フェーズ 1 の作業開始前に進捗ファイルを作成する
- MUST: 各フェーズ完了時に進捗ファイルを更新する

## デフォルト（L2 - ソフト）

品質の高い計画に重要。適切な理由がある場合はオーバーライド可。

- 探索/設計フェーズごとに2-3体の並列エージェントを起動
- 仕様書と設計の承認に改善ループ（最大3回反復）を使用
- トレードオフと却下されたアプローチを設計書に記録
- 次のフェーズに進む前に発見事項をユーザーに提示

## ガイドライン（L3）

効果的な計画のための推奨事項。

- consider: コードベース探索前にドメイン知識を確認する
- recommend: 単一の推奨ではなく、トレードオフ付きのオプションを提示する
- consider: 最終出力提示前にセルフレビューゲートを実行する
