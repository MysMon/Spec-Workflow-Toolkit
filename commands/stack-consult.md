---
description: "インタラクティブなスタックコンサルテーション: 要件ヒアリング、動的リサーチ、プロジェクトスキャフォールディング"
argument-hint: "[任意: プロジェクト名または簡単な説明]"
allowed-tools: AskUserQuestion, WebSearch, WebFetch, Read, Write, Bash, Glob, Grep, Task, TodoWrite, Edit
---

# /stack-consult - インタラクティブなスタックコンサルテーション

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

ドメインに依存しないコンサルテーションシステム。「アイデアがある」から「動くプロジェクト構造がある」まで、要件ベースのインタビューと動的な技術リサーチを通じてユーザーをガイドする。

## 設計原則

| 原則 | 実装 |
|-----------|----------------|
| **技術のハードコードなし** | すべてのオプションは WebSearch で発見 |
| **要件ファースト** | ソリューションのリサーチ前にニーズを理解 |
| **ドメイン非依存** | あらゆるプロジェクトタイプに対応 |
| **動的発見** | 最新情報のための RAG（WebSearch + WebFetch） |
| **透明なトレードオフ** | エビデンスに基づく比較 |

---

## ワークフロー概要

```
┌─────────────────────────────────────────────────────────────┐
│  フェーズ 1: 要件発見                                         │
│  「システムに何をさせたいですか？」                               │
├─────────────────────────────────────────────────────────────┤
│  フェーズ 2: 制約マッピング                                     │
│  「制限事項や希望は何ですか？」                                   │
├─────────────────────────────────────────────────────────────┤
│  フェーズ 3: 動的リサーチ（RAG）                                │
│  WebSearch + WebFetch で最新オプションを発見                      │
├─────────────────────────────────────────────────────────────┤
│  フェーズ 4: 分析と比較                                        │
│  要件に対してオプションを評価                                     │
├─────────────────────────────────────────────────────────────┤
│  フェーズ 5: 協調的意思決定                                     │
│  調査結果を提示し、一緒に決定                                     │
├─────────────────────────────────────────────────────────────┤
│  フェーズ 6: スキャフォールディング                                │
│  決定したスタックでプロジェクトをセットアップ                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 実行手順

### フェーズ 1: 要件発見

**目標**: 技術カテゴリではなく、システムの能力の観点でユーザーのニーズを理解する。

#### 1.1 コアパーパス

プロジェクトのビジョンを理解するためにオープンな質問から始める:

```
「何を構築しようとしていますか？誰が使い、どんな問題を解決しますか？」
```

自由回答を許容する。曖昧な場合はフォローアップ:
- 「このプロジェクトの成功とはどんな状態ですか？」
- 「典型的なユースケースを説明してもらえますか？」

#### 1.2 インタラクションモデル

```
Question: "ユーザーや他のシステムはどのようにこれとやり取りしますか？"
Header: "インタラクション"
Options:
- "ビジュアルインターフェースを通じて（画面、グラフィックス）"
- "テキスト/音声コマンドを通じて（CLI、チャットボット）"
- "API/メッセージ経由で他のソフトウェアから"
- "物理世界との接続（センサー、アクチュエーター、ハードウェア）"
- "直接的なインタラクションなし（バックグラウンド/バッチ処理）"
```

#### 1.3 データ特性

```
Question: "このシステムはどのようなデータを扱いますか？"
Header: "データ"
MultiSelect: true
Options:
- "構造化レコード（ユーザー、注文、在庫）"
- "非構造化コンテンツ（テキスト、ドキュメント、メディア）"
- "リアルタイムストリーム（イベント、センサー、ログ）"
- "バッチ処理を要する大規模データセット"
```

#### 1.4 通信パターン

```
Question: "どのような通信パターンが必要ですか？"
Header: "通信"
MultiSelect: true
Options:
- "リクエスト-レスポンス（ユーザーが問い合わせ、システムが応答）"
- "リアルタイム双方向（チャット、コラボレーション）"
- "プッシュ通知（アラート、更新）"
- "オフライン対応（ネットワークなしで動作）"
```

#### 1.5 デプロイメント環境

```
Question: "このシステムはどこで実行しますか？"
Header: "デプロイ"
Options:
- "ユーザーのデバイス（スマートフォン、デスクトップ、ブラウザ）"
- "クラウドサーバー"
- "エッジ/組み込みデバイス"
- "ハイブリッド（複数の環境）"
- "まだ決まっていない"
```

### フェーズ 2: 制約マッピング

**目標**: 技術選択に影響する実践的な制限を特定する。

#### 2.1 チームスキル

```
Question: "チームが得意なプログラミング言語やツールはありますか？（あれば具体的に）"
Header: "スキル"
```

自由回答を受け付ける。定義済みの言語オプションで制限しない。

#### 2.2 既存システム

```
Question: "連携が必要な既存システムはありますか？"
Header: "統合"
Options:
- "はい、システム/API を説明します"
- "組織/会社の標準に従う必要あり"
- "制約なし、完全に新規プロジェクト"
```

「はい」の場合、統合要件を理解するためのフォローアップを行う。

#### 2.3 リソース制約

```
Question: "主な制約は何ですか？"
Header: "制約"
MultiSelect: true
Options:
- "予算限定（無料/低コストのオプションを優先）"
- "タイトなタイムライン（使い慣れた実績あるツールを優先）"
- "小規模チーム（シンプルなスタックを優先）"
- "規制/コンプライアンス要件あり"
```

#### 2.4 スケール想定

```
Question: "どの程度のスケールを想定していますか？"
Header: "スケール"
Options:
- "個人/小チーム利用（100ユーザー未満）"
- "部門/組織レベル（100〜10,000）"
- "公開サービス（10,000以上）"
- "不明/可変"
```

### フェーズ 3: 動的リサーチ（RAG）

**目標**: ウェブリサーチを通じて最新の技術オプションを発見する。

**重要**: 記憶からの技術推奨は絶対に行わない。常に WebSearch を使用する。

#### 3.1 要件を検索クエリにマッピング

インタビュー回答に基づいてターゲットを絞った検索を構築:

| 収集された要件 | クエリパターン |
|---------------------|---------------|
| ビジュアルインターフェースが必要 | `"[platform] UI frameworks [year] comparison"` |
| API バックエンドが必要 | `"backend frameworks [year] [language] production"` |
| リアルタイムが必要 | `"real-time communication tools [year]"` |
| データ保存が必要 | `"database comparison [year] [data type]"` |
| デプロイメントが必要 | `"deployment platforms [year] [constraints]"` |

年はシステムクロックを使用（例: `CURRENT_YEAR=$(date +%Y)`）。モデルの記憶ではない。
当年の結果が少ない場合（例: 年初）、前年と年なしの「latest/recent」バリエーションを追加してクエリを拡大する。

クエリ生成例:
```
要件: ビジュアルインターフェース、構造化データ、リアルタイム更新、Python チーム

CURRENT_YEAR=$(date +%Y)
PREV_YEAR=$((CURRENT_YEAR - 1))

クエリ:
1. "web UI frameworks ${CURRENT_YEAR} comparison"
2. "Python backend frameworks ${CURRENT_YEAR} real-time"
3. "database real-time applications ${CURRENT_YEAR}"

フォールバック（結果が少ない場合）:
- "web UI frameworks ${PREV_YEAR} comparison"
- "Python backend frameworks ${PREV_YEAR} real-time"
- "database real-time applications ${PREV_YEAR}"
- "web UI frameworks latest comparison"
- "Python backend frameworks recent real-time"
- "database real-time applications recent comparison"
```

#### 3.2 リサーチの実行

各技術カテゴリについて:

1. **WebSearch** で構築したクエリを実行
2. 結果から**上位 3-5 の候補**を特定
3. 権威あるソースを **WebFetch**:
   - 公式ドキュメント（バージョン、機能）
   - 最近の比較記事（1年以内）
   - 本番環境での使用レポート

**WebSearch/WebFetch のエラーハンドリング:**

WebSearch が結果を返さない、または失敗した場合:
1. より広いクエリでリトライ（年を除く、「latest」や「recent」を追加）
2. 代替の検索用語で試行（同義語、関連概念）
3. それでも結果がない場合、ユーザーに通知:
   ```
   [カテゴリ] のリサーチで限定的な結果しか得られませんでした。

   オプション:
   1. 別の検索用語を試す（代替案を提案します）
   2. このカテゴリをスキップして利用可能な情報で進行
   3. リサーチする候補技術をあなたが提供
   ```

WebFetch が失敗した場合（タイムアウト、ブロック、利用不可）:
1. 検索結果の別のソースを試行
2. 基本情報として検索スニペットにフォールバック
3. 制限を記録: `"注: 公式ソースから検証できませんでした"`

#### 3.3 主要情報の抽出

各候補について:
- 現在のバージョン
- 主な強みと弱み
- 設計されたユースケース
- コミュニティの健全性指標
- ライセンスとコストモデル

#### 3.4 リサーチサマリーの作成

```markdown
## リサーチ結果: [カテゴリ]

### 発見された候補
| 名前 | バージョン | 最適な用途 | ソース |
|------|---------|----------|--------|
| [A]  | [ver]   | [用途]    | [url]  |
| [B]  | [ver]   | [用途]    | [url]  |

### 分析
[各候補の強み/弱みを含む分析結果]
```

### フェーズ 4: 分析と比較

**目標**: 発見されたオプションをユーザーの要件に対して評価する。

#### 4.1 評価フレームワークの適用

各候補について評価:

| 軸 | 質問 |
|------|----------|
| **要件適合** | 提示された問題を解決するか？ |
| **制約一致** | スキル、予算、タイムラインと互換か？ |
| **成熟度** | 本番対応可？メンテナンスされている？ |
| **エコシステム** | ドキュメント？ライブラリ？ツール？ |
| **統合性** | 選択した他のコンポーネントと連携するか？ |

#### 4.2 トレードオフマトリクスの作成

```markdown
| 観点 | [オプション A] | [オプション B] | [オプション C] |
|--------|------------|------------|------------|
| 要件 1 | 強い | 部分的 | 弱い |
| 要件 2 | 部分的 | 強い | 強い |
| チームスキル一致 | 強い | 弱い | 部分的 |
| 学習コスト | 低 | 高 | 中 |
```

#### 4.3 推奨の策定

```markdown
## 推奨

### 第一推奨: [技術]
**理由**: [ユーザー固有の要件に紐づけた理由]

### 代替案: [技術]
**こちらを検討する条件**: [こちらが良い場合の条件]
```

### フェーズ 5: 協調的意思決定

**目標**: 調査結果を提示し、一緒に意思決定する。

#### 5.1 ユーザーへの提示

以下を表示:
1. 要件のサマリー
2. 検索した内容
3. 発見された候補
4. トレードオフ分析
5. 根拠付きの推奨

#### 5.2 ユーザーの決定を取得

```
Question: "このリサーチ結果を踏まえて、どう進めますか？"
Header: "決定"
Options:
- "推奨案で良いので、プロジェクトをセットアップしましょう"
- "[特定のオプション] をもっと詳しく調べたい"
- "別のアプローチをリサーチしてほしい"
- "要件を見直したい"
```

#### 5.3 必要に応じて反復

- 特定技術についての追加リサーチ
- 特定オプション間のより深い比較
- 要件が変わった場合の再検討

#### 5.4 最終確認

```markdown
## 最終スタック決定

| コンポーネント | 選択 | 根拠 |
|-----------|--------|-----------|
| [レイヤー 1] | [技術] | [理由]     |
| [レイヤー 2] | [技術] | [理由]     |

セットアップを進めますか？
```

### フェーズ 6: スキャフォールディング

**目標**: 決定した技術でプロジェクトをセットアップする。

#### 6.1 セットアップコマンドのリサーチ

**セットアップコマンドを想定しないこと。** 最新の公式手順を検索:

年はシステムクロックを使用（例: `CURRENT_YEAR=$(date +%Y)`）。モデルの記憶ではない。
当年の結果が少ない場合、前年や年なしの「latest/recent」クエリも試す。

```
WebSearch: "[technology] getting started official documentation ${CURRENT_YEAR}"
WebFetch: [公式ドキュメント] → "インストールとセットアップコマンドを抽出"
```

#### 6.2 セットアップの実行

公式ドキュメントのコマンドを実行する。

#### 6.3 セットアップ後のタスク

1. 適切な .gitignore で **git を初期化**
2. 以下を記録した **CLAUDE.md を作成**:
   - 根拠付きの決定スタック
   - セットアップに使用したコマンド
   - 主要な決定事項
3. セットアップの**動作を確認**（ビルド、実行）

#### 6.4 ハンドオフ

```markdown
## プロジェクトセットアップ完了

### スタック
[バージョン付きの技術]

### 使用したコマンド
[正確なセットアップコマンド]

### 次のステップ
- [最初の推奨アクション]
- [2番目の推奨アクション]

### 作成されたドキュメント
- CLAUDE.md - Claude 向けコンテキスト
- README.md - 人間向けドキュメント
```

---

## 使用例

```bash
# ゼロからのフルコンサルテーション
/stack-consult

# プロジェクトコンテキスト付き
/stack-consult 在庫管理システム

# 別の要件でコンサルテーションを再開
/stack-consult
```

---

## ルール（L1 - ハード）

正確で最新の推奨を提供するために不可欠。

- NEVER: WebSearch でリサーチせずに技術を推奨する
- NEVER: トレーニングデータから機能やセットアップコマンドを想定する
- NEVER: フェーズ 1 の質問で技術固有のオプションを使用する（要件ファースト）
- MUST: スキャフォールディング前に決定を確認する（ユーザーの承認が必要）
- MUST: すべての検索でシステムクロックから当年を使用する（`CURRENT_YEAR=$(date +%Y)`）
- NEVER: 年、バージョン、コマンド構文にトレーニングデータを使用する — 常に WebSearch で検証
- MUST: 年を考慮した検索クエリを使用し、結果が少ない場合は前年のフォールバックを追加する
- MUST: フェーズ 1-2 のすべての要件収集に AskUserQuestion を使用する
- NEVER: ユーザーの要件を推測する — 常に明示的に確認

## デフォルト（L2 - ソフト）

品質の高いコンサルテーションに重要。適切な理由がある場合はオーバーライド可。

- 最新オプションの発見に WebSearch を使用
- リサーチエビデンスに基づくトレードオフを提示
- 公式ドキュメントからセットアップコマンドを検証
- プロジェクトセットアップ後に CLAUDE.md を作成

## ガイドライン（L3）

効果的なコンサルテーションのための推奨事項。

- consider: 技術カテゴリごとに 3-5 の候補を提示する
- recommend: 複雑な意思決定にはトレードオフマトリクスを作成する
