---
description: "プロジェクトを分析し、スタック検出とユーザーインタビューを通じて .claude/rules/ ファイルを生成する"
argument-hint: "[任意: フォーカス領域 - 例: 'frontend', 'testing']"
allowed-tools: Read, Write, Glob, Grep, Bash, AskUserQuestion, Task, TodoWrite
---

# /project-setup - プロジェクトルール生成

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

コードベースの分析とユーザーへの規約・好みに関するインタビューを通じて、プロジェクト固有の `.claude/rules/` ファイルを生成する。

## 設計原則

1. **推測せず発見する**: ハードコードされたファイルリストではなく、分析を通じてスタックを検出する
2. **ドメイン非依存**: あらゆるプロジェクトタイプ（Web、モバイル、CLI、組み込み等）で動作する
3. **ユーザー主導**: 検出できない規約をインタビューで理解する
4. **パターンベース**: 技術カテゴリではなく、発見されたパターンに基づいてルールを生成する

---

## フェーズ概要

```
フェーズ 1: スタック検出    → 分析を通じた技術スタックの発見
フェーズ 2: パターン分析    → コード内の既存規約の発見
フェーズ 3: ユーザーインタビュー → 質問による好みの収集
フェーズ 4: ルール生成      → .claude/rules/ ファイルの作成
フェーズ 5: レビューと確認  → ユーザー承認
```

---

## 実行手順

### フェーズ 1: スタック検出

**目的:** 分析を通じてプロジェクトの技術スタックを発見する。

**重要: スタック検出は code-explorer エージェントに委任する（手動で調査しないこと）:**

```
code-explorer エージェントを起動:
タスク: プロジェクトの技術スタックを検出
分析対象:
- 一般的な指標からのプロジェクトタイプ（*.json, *.toml, *.yaml 等）
- ファイル拡張子からの主要言語
- ビルド/パッケージ設定ファイル
- パッケージマネージャーと依存関係
- テストセットアップ（存在する場合）
- ビルド/リント設定（存在する場合）

Thoroughness: quick
出力: 検出された技術のスタックプロファイルサマリー
```

エージェントの出力をスタックサマリーとして使用する。手動で検出コマンドを実行しないこと。

**エラーハンドリング:**
code-explorer が失敗またはタイムアウトした場合:
1. スコープを縮小して1回リトライする（主要言語とビルドシステムのみに焦点）
2. リトライも失敗した場合、ユーザーに通知する:
   ```
   スタック検出に失敗しました。プロジェクトの技術を判定できません。

   選択肢:
   1. スタック検出をリトライ
   2. スタックを手動で説明する（自動検出をスキップ）
   3. セットアップをキャンセル
   ```
3. ユーザーが選択肢 2 を選んだ場合: AskUserQuestion を使用してスタック情報を手動で収集する

**出力:** ユーザー確認用のスタックサマリー（特定のフレームワークを推測しない）。

### フェーズ 2: パターン分析

**目的:** 推測ではなく、コード分析を通じて既存の規約を発見する。

**`code-explorer` エージェントに委任する:**

```
code-explorer エージェントを起動して分析:
- ディレクトリ構造と命名規則
- コード構成パターン（機能別、レイヤー別等）
- インポート/エクスポートパターン
- エラーハンドリングパターン
- テストパターン（ファイル配置、命名）
- ドキュメントパターン

Thoroughness: medium
出力: file:line の例を含む規約サマリー
```

**重要: 設定ファイルチェックのために別途 Glob コマンドを実行しないこと。**

上記の code-explorer エージェントは、分析に設定ファイルの発見を既に含んでいる:
- `.claude/`, `CLAUDE.md`, `.claude/rules/`
- 品質ツールの設定（`.*rc*`, `*.config.*`）
- エディタ設定（`.editorconfig`, `.vscode/`, `.idea/`）

エージェントの出力を直接使用する。別途 Glob コマンドで重複させないこと。

**エラーハンドリング:**
code-explorer が失敗またはタイムアウトした場合:
1. スコープを縮小して1回リトライする（ディレクトリ構造とテストパターンのみに焦点）
2. リトライも失敗した場合、ユーザーに通知する:
   ```
   パターン分析に失敗しました。

   選択肢:
   1. パターン分析をリトライ
   2. パターン分析をスキップしてインタビューのみで進行
   3. セットアップをキャンセル
   ```
3. ユーザーが選択肢 2 を選んだ場合: パターンデータなしでフェーズ 3 に進む（インタビュー回答がルール生成を導く）

**出力:** コードベースからの具体例を含む発見されたパターン（エージェント出力から）。

### フェーズ 3: ユーザーインタビュー

**目的:** コード分析では検出できない好みを収集する。

**ドメイン非依存の質問を使用する:**

#### 3.1 コードスタイルの好み

```
検出されたスタックに基づく: [スタックサマリー]

Question: "Claude にはどのようなコードスタイル規約に従ってほしいですか？"
Header: "コードスタイル"
Options:
- "既存のツール設定に従う（検出: [ツール]）"
- "コードベースで見つかったパターンに合わせる"
- "カスタムルールを指定する"
- "言語/フレームワークのデフォルトを使用する"
```

#### 3.2 テストアプローチ

```
Question: "Claude にはどのテストアプローチを使用してほしいですか？"
Header: "テスト"
Options:
- "既存のテストパターンに合わせる（検出: [パターン]）"
- "テスト駆動開発（テストを先に書く）"
- "実装後にテスト"
- "テスト要件を指定する"
```

#### 3.3 ドキュメントスタイル

```
Question: "Claude にはどのドキュメントスタイルに従ってほしいですか？"
Header: "ドキュメント"
Options:
- "公開 API のみドキュメント化"
- "包括的なドキュメント"
- "最小限（自己説明的なコード）"
- "既存のドキュメントスタイルに合わせる"
```

#### 3.4 アーキテクチャ境界

```
Question: "異なるルールを適用すべき領域はありますか？"
Header: "境界"
MultiSelect: true
Options:
- "コードベースの部分ごとに異なるルールが必要"
- "特に注意が必要な領域がある"
- "特定の領域で厳格なバリデーションが必要"
- "特別な境界は不要"
```

ユーザーが境界を選択した場合、どのパス/パターンかフォローアップして確認する。

#### 3.5 セキュリティ考慮事項

```
Question: "どのようなセキュリティ考慮事項がありますか？"
Header: "セキュリティ"
MultiSelect: true
Options:
- "認証/認可コードには特別な注意が必要"
- "入力バリデーションが重要"
- "機密データを扱う（PII、認証情報）"
- "標準的なセキュリティプラクティスで十分"
```

#### 3.6 カスタムルール

```
Question: "Claude が知っておくべきプロジェクト固有のルールはありますか？"
Header: "カスタム"
Options:
- "はい、説明します"
- "追加ルールは不要"
```

### フェーズ 4: ルール生成

**目的:** 分析とインタビューに基づいて `.claude/rules/` ファイルを生成する。

**ディレクトリの作成:**

```bash
mkdir -p .claude/rules
```

**調査結果に基づいてルールファイルを生成する（ハードコードされたテンプレートではなく）:**

#### 4.1 汎用ルール（常に作成）

`.claude/rules/general.md` を作成:

```markdown
# プロジェクト: [分析から得たプロジェクト名]

## 技術スタック
[検出されたスタック - 推測ではなく発見されたもの]

## コードスタイル
[インタビュー + 検出されたパターンから]

## テスト
[インタビュー + 検出されたパターンから]

## ドキュメント
[インタビューから]

## 追加コンテキスト
[インタビューからのカスタムルール]
```

#### 4.2 パス条件付きルール（境界が特定された場合）

以下の場合のみパス固有のルールを作成する:
1. ユーザーが領域ごとに異なるルールを指定した場合
2. 分析でコードベースに明確な分離が見つかった場合

**フェーズ 2 の分析でパスを発見する。ハードコードしたりコマンドを実行したりしないこと:**

フェーズ 2 の code-explorer エージェントが既にディレクトリ構造を発見している。その出力を直接使用する。

親コンテキストで find コマンドを実行しないこと。追加のパス検出が必要な場合は code-explorer に委任する。

発見されたパス（フェーズ 2 のエージェント出力から）を使用してパス条件付きルールを作成:

```yaml
---
paths:
  - "[発見されたパスパターン]"
---

# [領域] 開発ルール

[インタビューからのこの領域固有のルール]
```

### フェーズ 5: レビューと確認

**目的:** 生成されたルールをユーザー承認のために提示する。

**サマリーを表示する:**

```markdown
## 生成ルールサマリー

### 作成されたファイル
| ファイル | スコープ | 主要ルール |
|----------|----------|------------|
| `general.md` | 全ファイル | [サマリー] |
| [パス固有（作成された場合）] | [パス] | [サマリー] |

### ルールハイライト
- [インタビューに基づく主要ルール 1]
- [分析に基づく主要ルール 2]

選択肢:
1. これらのルールをそのまま適用
2. 適用前にレビュー・編集
3. 異なる設定で再生成
4. キャンセル
```

**最終出力:**

```markdown
ルールが .claude/rules/ に作成されました。

これらのルールは Claude がこのプロジェクトで作業する際に自動的に読み込まれます。

次のステップ:
1. .claude/rules/ 内の生成されたルールをレビュー
2. バージョン管理に追加: git add .claude/rules/
3. 一貫した AI アシスタンスのためにチームと共有
```

---

## 使用例

```bash
# インタビュー付きのフルセットアップ
/project-setup

# 特定の領域にフォーカス（的を絞った質問をする）
/project-setup testing
/project-setup security

# コードベース変更後に再生成
/project-setup
```

---

## ルール（L1 - ハード）

正確なプロジェクトルールのために重要。

- NEVER: 特定のフレームワーク/ライブラリ名を推測する（分析を通じて発見する）
- NEVER: パスパターンをハードコードする（コードベースから発見する）
- NEVER: 検出されていない技術に対してルールを作成する
- NEVER: ファイル作成前にユーザー確認をスキップする

## デフォルト（L2 - ソフト）

効果的なルール生成のために重要。適切な理由がある場合はオーバーライド可能。

- ハードコードされたファイルリストではなく、分析を通じてスタックを発見する
- ドメイン非依存のインタビュー質問を使用する
- 検出されたパターンをユーザーに確認する
- パス条件付きルールには発見されたパスを使用する

## ガイドライン（L3）

包括的なプロジェクトセットアップのための推奨事項。

- consider: 明確な境界が存在する場合、パス固有のルール生成を行う
- prefer: 既存のエディタ/ツール設定との整合を取る
