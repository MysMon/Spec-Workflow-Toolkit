---
description: "5つの並列スペシャリストエージェントによる信頼度ベースのスコアリングとフィルタリングを用いたコードレビュー（必要条件: PR レビュー用の GitHub CLI 'gh'）"
argument-hint: "[ファイルパス、ディレクトリ、PR 番号、または 'staged' で git ステージ済みの変更]"
allowed-tools: Read, Glob, Grep, Bash, Task, AskUserQuestion
---

# /code-review - 並列コードレビュー

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

5つのスペシャリストエージェント（CLAUDE.md 準拠、バグスキャン、Git 履歴、PR コメント、コードコメント）を並列起動してコード変更を包括的にレビューし、各指摘を Sonnet エージェントで信頼度ベースのフィルタリングによりスコアリングする。

公式の code-review プラグインパターンに基づく。

## 概要

このコマンドは8ステップのワークフローを実装する:

1. **適格性チェック** (Sonnet) - PR がレビュー可能か確認
2. **CLAUDE.md 探索** (Sonnet) - すべてのガイドラインファイルを検索
3. **変更サマリー** (Sonnet) - PR の変更を要約
4. **並列レビュー** (5エージェント: 準拠、バグスキャン、Git 履歴、PR コメント、コードコメント) - 異なる観点から分析
5. **信頼度スコアリング** (N個の Sonnet エージェント) - 各指摘をスコアリング
6. **フィルタリング** - 信頼度80%未満の指摘を除去
7. **適格性再チェック** (Sonnet) - 投稿前に確認
8. **レポート** - GitHub リンク付きで結果を投稿

## 信頼度スコアリング基準

各指摘は以下のスケールでスコアリングされる:

| スコア | 意味 | 使用する場面 |
|--------|------|-------------|
| **0** | まったく確信がない | 誤検知、既存の問題、または明示されていない好み |
| **25** | やや確信がある | 実際の問題かもしれないが未検証 |
| **50** | 中程度の確信 | 実際の問題だが軽微/稀な発生 |
| **75** | 高い確信 | 検証済みで実際に発生し、重大な影響がある |
| **100** | 絶対的に確実 | 間違いなく実際の問題で、頻繁に発生し、直接検証可能 |

**デフォルトしきい値:** 80（スコアが80以上の指摘のみ報告）

### CLAUDE.md 指摘の検証

CLAUDE.md に起因する指摘の場合:
- CLAUDE.md がその問題を**明示的に**指摘しているか再確認する
- ガイドラインが曖昧または直接適用されない場合は低スコアにする

## 実行手順

### ステップ 1: 変更ファイルの特定

**ゴール:** ファイルリストのみ（メタデータ）を取得する。これは大量のコンテキストを消費しない軽量な操作である。

`$ARGUMENTS` に基づき、**ファイルリストのみ**を取得する:

**"staged" または空の場合:**
```bash
git diff --staged --name-only
```

**ファイルパスまたはディレクトリの場合:**
```bash
git diff HEAD --name-only -- [path]
# git 管理外の場合は Glob でファイルを一覧
```

**PR 番号の場合（例: "#123"）:**
```bash
gh pr diff 123 --name-only
```

**これが許可される理由（委任不要）:**
- `--name-only` はファイルパスのみを返し、内容は含まない
- これはメタデータの探索であり、内容分析ではない
- コンテキスト消費は最小限（通常100行未満）

**CRITICAL: `--name-only` なしで `git diff` を実行してはならない。差分内容（コンテキストを消費する）はステップ 2 で code-explorer が収集しなければならない。**

### ステップ 2: コンテキスト収集（差分内容を含む）

**CRITICAL: 差分内容を含むすべてのコンテキスト収集を code-explorer に委任する。**

```
Task ツールで subagent_type=Explore を起動:

プロンプト:
コードレビュー用のレビューコンテキストを収集する。

タスク:
1. 変更ファイルの差分内容を取得（git diff --staged または git diff HEAD -- [files]）
2. すべての CLAUDE.md ファイルと .claude/rules/*.md ファイルを検索
3. 変更ファイルに関連する主要ガイドラインを要約
4. 変更行の git blame を取得（最近の著者を特定）
5. これらのファイルに影響する最近のコミット履歴を取得

変更ファイル:
[ステップ 1 のファイルリスト]

レビュー範囲:
[staged / file / directory / PR#]

出力:
- 差分内容（大きい場合は要約、小さい場合は全文）
- CLAUDE.md ガイドラインの要約（関連ルールのみ）
- Git 履歴コンテキスト（最近の変更、著者）
- 影響を受ける可能性のある関連ファイル

網羅度: quick
```

ステップ 3 のエージェントプロンプトには code-explorer の出力（差分内容を含む）を使用する。親コンテキストで差分内容を直接読んではならない。

**code-explorer のエラーハンドリング:**
code-explorer が失敗またはタイムアウトした場合:
1. 部分的な出力に利用可能なコンテキストがないか確認
2. **フォールバック: 最小限のコンテキスト収集**（`subagent-contract` の統一リミットに従う）:
   - Glob で CLAUDE.md を確認: `**/CLAUDE.md`
   - CLAUDE.md がある場合: 直接読み込む（200行以下）
   - CLAUDE.md がない場合: ガイドラインなしで続行（エージェント 1 が「ガイドラインが見つかりません」と報告）
   - 差分内容を取得: `git diff --staged`（200行以下、超過時は警告付きで切り捨て）
3. **限定コンテキストについてユーザーに警告:**
   ```
   Question: "コンテキスト収集に失敗しました。限定的な情報でのレビューとなります。どうしますか？"
   Header: "限定コンテキスト"
   Options:
   - "限定レビューで進める（一部の問題を見逃す可能性あり）"
   - "コンテキスト収集を再試行"
   - "キャンセルして問題を調査"
   ```
4. ユーザーが続行を選択した場合: 利用可能なコンテキストでステップ 3 を続行
5. 最終レポートに注記: "限定コンテキストでのレビュー - Git 履歴および関連ファイル分析は利用不可"

**git diff も失敗するか、内容が多すぎる場合（500行超）:**
- ユーザーにスコープの絞り込みを依頼: ファイルを指定するか `staged` モードを使用
- コンテキストを圧迫する大量の差分で処理を続行してはならない

### ステップ 3: 5つの並列レビューエージェントを起動（Sonnet）

**CRITICAL: 5つすべてのエージェントを1つのメッセージ内で5つの個別 Task ツール呼び出しとして起動する。**

真の並列処理を実現するため、1つのレスポンスで複数の Task ツールを呼び出す:
```
<parallel-execution>
Task ツール呼び出し 1: エージェント 1（CLAUDE.md 準拠）
Task ツール呼び出し 2: エージェント 2（バグスキャン）
Task ツール呼び出し 3: エージェント 3（Git 履歴）
Task ツール呼び出し 4: エージェント 4（PR コメント）
Task ツール呼び出し 5: エージェント 5（コードコメント）
</parallel-execution>
```

各 Task は `subagent_type: general-purpose` で `model: inherit` を使用（またはエージェントのデフォルトモデルを使用するため省略）。

**エージェント 1: CLAUDE.md 準拠監査**
```
CLAUDE.md ガイドラインへの準拠をレビューする。

CLAUDE.md ファイル:
[CLAUDE.md のパスと内容のリスト]

レビュー対象の変更:
[差分内容]

検出された各違反について返すこと:
- 違反したガイドライン（具体的なルールを引用）
- コード位置（file:line）
- 簡潔な説明
```

**エージェント 2: 簡易バグスキャン**
```
変更されたコードのみを対象に明らかなバグをレビューする。

レビュー対象の変更:
[差分内容]

この変更で導入されたバグのみに注目し、既存の問題は対象外。

注目すべき点:
- ロジックエラー、オフバイワンエラー
- null/undefined のハンドリング問題
- レースコンディション、リソースリーク
- 不正なエラーハンドリング

各バグについて:
- バグの説明
- コード位置（file:line）
```

**エージェント 3: Git 履歴コンテキスト分析**
```
git blame と履歴を分析してコンテキストに基づく問題を検出する。

変更ファイル:
[ファイルリスト]

変更行の git blame を実行する。
これらのファイルの最近のコミット履歴を確認する。

各問題について:
- 問題の説明
- コード位置（file:line）
- 歴史的コンテキスト（なぜ問題になりうるか）
```

**エージェント 4: 関連 PR コメントレビュー**
```
関連する PR のコメントやディスカッションを確認する。

変更ファイル:
[ファイルリスト]

このコードに適用される可能性のある既存のレビューコメントや
ディスカッションを検索する。

各関連する発見について:
- 発見の説明
- コード位置（file:line）
- 以前のディスカッションへの参照
```

**エージェント 5: コードコメントの整合性**
```
コードの動作がインラインコメントと一致しているか検証する。

レビュー対象の変更:
[差分内容]

以下を確認:
- コメントがコードを正確に説明しているか
- TODO が対応済みまたはまだ有効か
- 誤解を招くコメントがないか

各不整合について:
- 問題の説明
- コード位置（file:line）
```

**並列エージェントのエラーハンドリング:**
レビューエージェントのいずれかが失敗またはタイムアウトした場合:
1. 失敗したエージェントの部分的な出力に利用可能な発見がないか確認
2. 成功したエージェントの結果で続行
3. 最終レポートの「カバレッジの制限」に失敗したエージェントを記載
4. 3つ以上のエージェントが失敗した場合: ユーザーに警告し、再試行または部分的な結果での続行を提案

### ステップ 4: Sonnet エージェントで各指摘をスコアリング

**ステップ 3 で検出された各指摘に対して、並列 Sonnet エージェントを起動**して信頼度をスコアリングする。

```
N個の並列 Sonnet エージェントを起動（指摘ごとに1つ）:

各指摘について:
- PR コンテキスト: [PR サマリー]
- 指摘の説明: [ステップ 3 から]
- CLAUDE.md ファイル: [ガイドラインファイルのリスト]

基準に基づいてこの指摘を0-100でスコアリングする。
CLAUDE.md の指摘については、ガイドラインが明示的に言及しているか確認する。
```

**スコアリングエージェントのエラーハンドリング:**
スコアリングエージェントが失敗した場合:
1. スコアリングされていない指摘にデフォルト信頼度70を割り当てる
2. これらの指摘をレポートで「未スコアリング」とマーク
3. フィルタリングを続行（未スコアリングの指摘はデフォルトの80しきい値で除外、ユーザーがしきい値を下げない限り）

### ステップ 5: フィルタリングと重複排除

**スコアが80未満の指摘を除去する。**

**重複排除戦略:**
- **同じ file:line + 同じカテゴリ** → 最も高い信頼度を保持し、説明をマージ
- **同じ file:line + 異なるカテゴリ** → 両方保持（例: バグ AND CLAUDE.md 違反）
- **複数エージェントが同じ問題を指摘** → 信頼度を10ブースト（最大100）
- **重複する行範囲** → 50%以上の重複かつ同じカテゴリの場合はマージ

**自動フィルタ（報告しない）:**
- この変更に含まれない既存の問題
- リンター/型チェッカーが検出する問題
- 些末なニットピック
- lint-ignore コメント付きのコード
- CLAUDE.md にない一般的なコード品質の問題
- ユーザーが変更していない行の問題
- 意図的な機能変更

### ステップ 6: 適格性の再チェック

提示前に確認:
- PR がまだオープンか（クローズまたはマージされていないか）
- 分析開始以降に新しいコミットがないか
- 指摘がまだ有効か

### ステップ 7: レビュー結果の提示

**PR レビューの場合（GitHub に投稿）:**

```markdown
## コードレビュー

[N] 件の問題を検出:

1. [簡潔な説明]（CLAUDE.md に「[ガイドラインを引用]」とある）

   `path/file.ext#L[start]-L[end]`

2. [簡潔な説明]（[説明] によるバグ）

   `path/file.ext#L[start]-L[end]`

```

**リンクフォーマットの要件:**
- 完全な SHA を使用（短縮版ではない）
- 行参照には `#L` 表記を使用
- 問題の前後に少なくとも1行のコンテキストを含める

**ローカルレビューの場合:**

```markdown
## コードレビュー

[N] ファイル、[M] 行の変更をレビューしました。

### 重大な問題（信頼度 >= 90）

1. **[問題のタイトル]** - [カテゴリ]（スコア: [N]）

   ファイル: `src/auth.ts:67-72`

   [問題の説明]

   **修正案:** [提案する修正]

### 重要な問題（信頼度 80-89）

...

### サマリー

- 重大: [N]
- 重要: [N]
- フィルタ済み（しきい値未満）: [N]

**判定:** [APPROVED / NEEDS CHANGES]
```

### ステップ 8: ユーザーアクション

ユーザーに質問する:
```
レビュー完了。どうしますか？
1. 重大な問題を今すぐ修正
2. すべての問題を今すぐ修正
3. 変更なしで続行
4. 特定の問題について詳細を確認
```

## 使用例

```bash
# ステージ済みの変更をレビュー
/code-review staged
/code-review

# 特定のファイルをレビュー
/code-review src/auth/login.ts

# ディレクトリをレビュー
/code-review src/components/

# PR をレビュー
/code-review #123
```

## 設定

### 信頼度しきい値の調整

リクエスト内で:
```
/code-review staged --threshold 60
```

### フォーカスモード

```
/code-review staged --focus security
/code-review staged --focus bugs
```

## Git との連携

レビュー後、承認された場合:
```bash
# ステージしてレビュー参照付きでコミット
git add .
git commit -m "feat: 機能 X を実装

コードレビュー完了:
- セキュリティ: 合格
- 品質: 合格
- 準拠: 合格"
```

## /spec-review との比較

| 側面 | /spec-review | /code-review |
|------|-------------|-------------|
| いつ | 実装前 | 実装後 |
| 何を | 仕様書 | コード変更 |
| 焦点 | 完全性、実現可能性 | バグ、セキュリティ、品質 |
| 出力 | 仕様の改善 | コードの修正 |

---

## ルール（L1 - ハード）

正確で有用なコードレビューのために不可欠。

- MUST: 真の並列処理のため5つのレビューエージェントを1つのメッセージで起動する
- NEVER: エージェントを順次起動してはならない（並列実行の利点が失われる）
- MUST: 信頼度基準を用いて各指摘を0-100でスコアリングする
- NEVER: 信頼度80未満の指摘を報告してはならない（デフォルトしきい値）
- MUST: 結果提示前に PR の適格性を再チェックする
- NEVER: PR がクローズまたはマージ済みの場合にレビューを投稿してはならない
- MUST: 以下の場合に AskUserQuestion を使用する:
  - ユーザーが問題の修正を希望する場合（どの問題か確認）
  - 複数の修復アプローチが存在する場合
  - 問題の優先度について明確化が必要な場合
- ALWAYS: 報告する指摘に file:line 参照を含める

## デフォルト（L2 - ソフト）

品質の高いレビューのために重要。適切な理由がある場合はオーバーライド可。

- 5つのエージェントを起動: 準拠、バグスキャン、Git 履歴、PR コメント、コードコメント
- 複数エージェントからの指摘を重複排除（信頼度を10ブースト）
- 信頼度スコアリングに Sonnet エージェントを使用
- 信頼度レベル別に結果をグループ化して提示（重大 >= 90、重要 80-89）

## ガイドライン（L3）

効果的なコードレビューのための推奨事項。

- consider: PR レビューでは GitHub パーマリンク形式での指摘提示を検討
- prefer: 些末なニットピックやリンターで検出可能な問題はフィルタリングする
- consider: 複数の問題が検出された場合、修正の優先度についてユーザーに確認する
