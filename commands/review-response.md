---
description: "PR レビューコメントに対応する - フィードバックを分析し、変更を実装し、体系的に返信する（必要: GitHub CLI 'gh'）"
argument-hint: "<PR 番号 or URL>"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, AskUserQuestion, Task, TodoWrite
---

# /review-response - PR レビュー対応ワークフロー

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

PR レビューコメントを効率的に処理するための構造化ワークフロー。レビューアーのフィードバックを分析し、要求された変更を実装し、回答を準備する。

## 設計原則

1. **行動前に理解する**: 変更を加える前にすべてのコメントを読む
2. **関連する変更をまとめる**: 類似のフィードバックをグループ化してコンフリクトを回避
3. **回答を追跡する**: すべてのコメントに対応していることを確認する
4. **レビューアーの意図を尊重する**: フィードバックが不明確な場合は確認する

---

## 使用タイミング

- PR にレビューコメントが付いた場合
- 複数のレビューアーからのフィードバックに対応する必要がある場合
- レビュー回答の体系的な追跡が必要な場合
- 変更を実装しレビューアーに返信する必要がある場合

## 入力形式

```bash
# PR 番号（gh CLI または MCP GitHub サーバーが必要）
/review-response 123

# PR URL（GitHub, GitLab 等）
/review-response <PR URL>

# 現在のブランチの PR
/review-response
```

---

## 実行手順

### フェーズ 1: レビューコメントの収集

**目的:** すべてのレビューコメントを収集し、分類する。

**PR コメントの取得:**

**重要: 使用前に PR 番号のフォーマットを検証すること:**
- PR 番号は正の整数であること（例: `123`, `4567`）
- 不明な場合は `gh pr view` を番号なしで実行して現在のブランチの PR を取得する

```bash
# GitHub CLI を使用（PR_NUMBER は数値であることを検証済み）
gh pr view "$PR_NUMBER" --comments
gh pr view "$PR_NUMBER" --json reviews,comments

# 特定のファイルに対するレビューコメントを取得
gh api "repos/{owner}/{repo}/pulls/${PR_NUMBER}/comments"
```

**PR 番号が指定されていない場合:**

```bash
# 現在のブランチの PR を検索
gh pr view --json number,title,url
```

**コメントの分類:**

| カテゴリ | 説明 | 優先度 |
|----------|------|--------|
| **必須変更** | 「修正必須」、承認をブロックする | 高 |
| **提案** | 「検討して」「もしかしたら」、改善案 | 中 |
| **質問** | 明確化のリクエスト | 中 |
| **細かい指摘** | スタイル、命名、軽微な点 | 低 |
| **称賛** | ポジティブなフィードバック | N/A |

### フェーズ 2: 対応計画の作成

**目的:** 各コメントへの対応方法を計画する。

**TodoWrite リストを作成する:**

```
各コメントについて:
1. ファイルパスと行番号
2. コメントカテゴリ
3. 計画されたアクション（実装/議論/辞退）
4. 想定される複雑さ
```

**関連するコメントをグループ化する:**

```
グループ化の基準:
- 同じファイル（変更をまとめる）
- 同じレビューアー（コンテキストを維持）
- 同じトピック（一貫したアプローチ）
```

**コメントが多い場合は優先順位を確認する:**

```
Question: "[N] 件のレビューコメントを見つけました。どのように優先順位をつけますか？"
Header: "優先度"
Options:
- "必須変更を先に"（推奨）
- "ファイル別（コンフリクトを最小化）"
- "簡単なものから先に"
- "特定の項目を選択する"
```

### フェーズ 3: 変更の実装

**目的:** 要求された変更を体系的に実施する。

**各コメントグループについて:**

**ステップ 1: フィードバックを理解する**

```
code-explorer エージェントを起動して分析:

レビューコメント: [コメント内容]
ファイル: [ファイルパス]
行: [行番号]

タスク:
1. レビュー対象のコードを読み取る
2. レビューアーの懸念を理解する
3. 他の箇所に類似パターンがないか確認する
4. フィードバックに対応する最適なアプローチを特定する

Thoroughness: quick
```

**ステップ 2: 変更を実装する**

**常に適切なスペシャリストに実装を委任すること:**

```
Task ツールで適切なスペシャリストを起動:

- コードロジック → backend-specialist または frontend-specialist
- テスト → qa-engineer
- アーキテクチャの懸念 → code-architect

プロンプト:
PR レビューコメントに対応。

レビューコメント: [コメント内容]
ファイル: [ファイルパス]
行: [行番号]
元のコード: [コードスニペット]
発見された類似パターン: [ステップ 1 から]

コードベースのパターンに従って要求された変更を実装する。
```

**TRIVIAL な変更に限り直接修正が許可される:**
基準は `subagent-contract` スキル「TRIVIAL Edit Definition」を参照:
- コメントや文字列内の一行タイプミス修正
- フォーマットのみの変更（空白、インデント）

**ステップ 3: 対応済みとしてマークする**

各変更後に TodoWrite を更新する。

### フェーズ 4: 議論の処理

**目的:** 議論が必要なコメントへの回答を準備する。

**レビューアーからの質問に対して:**

```
code-explorer を起動してコンテキストを収集:
- なぜこの実装を選んだのか？
- どのような代替案を検討したか？
- トレードオフは何か？

理由を説明する簡潔な回答を準備する。
```

**同意できない提案に対して:**

1. レビューアーの視点を理解する
2. 理由を添えた丁寧な反論を準備する
3. 可能であれば妥協案を提示する

**議論項目についてユーザーに確認する:**

```
Question: "この提案にどう対応しますか？"
Header: "回答"
Options:
- "提案通りに実装する"
- "代替案を提案する: [簡単な説明]"
- "理由を添えて丁重にお断りする"
- "レビューアーに明確化を求める"
```

### フェーズ 5: 検証

**目的:** すべての変更が正しく動作することを確認する。

**重要: 検証は qa-engineer エージェントに委任する（親コンテキストでテストを直接実行しないこと）:**

```
qa-engineer エージェントを起動:

タスク: PR レビュー変更の検証

変更されたファイル:
[フェーズ 3 で修正されたファイルのリスト]

実行:
1. テスト（npm test / pytest / go test 等）
2. リント（npm run lint / eslint 等）
3. ビルドチェック（npm run build 等）

出力:
- テスト結果（PASS/FAIL）
- リント結果（PASS/FAIL）
- ビルド結果（PASS/FAIL）
- 失敗があればエラー詳細
```

エージェントの出力を検証結果として使用する。親コンテキストで test/lint/build コマンドを直接実行しないこと。

**エラーハンドリング:**
qa-engineer が失敗またはタイムアウトした場合:
1. エージェントの部分的な出力に使用可能な結果がないか確認する
2. スコープを簡略化して1回リトライする（テストのみ）
3. リトライも失敗した場合、ユーザーに通知し選択肢を提示する:
   - 「検証をリトライする」
   - 「自動検証をスキップする（手動で検証する）」
   - 「手動実行用のコマンドを表示する」

**コンフリクトの確認（親コンテキストで許可 - 軽量な git 状態コマンド）:**

```bash
# 変更がコンフリクトしていないことを確認
git status
git diff --stat
```

### フェーズ 6: コミットの準備

**目的:** レビュー対応のクリーンなコミットを作成する。

**コミットメッセージの形式:**

```
fix: PR レビューフィードバックに対応

- [変更 1 のサマリー]
- [変更 2 のサマリー]
- [変更 3 のサマリー]

@reviewer からのレビューコメントに対応
```

**コミットについて確認する:**

```
Question: "すべての変更が実装されました。どのように進めますか？"
Header: "コミット"
Options:
- "すべての変更を1つのコミットにまとめる"
- "カテゴリ別にコミットを分ける"
- "まず diff を確認する"
- "手動でコミットする"
```

### フェーズ 7: サマリーレポート

**目的:** レビュー対応の概要を提供する。

```markdown
## レビュー対応サマリー

### PR: #[番号] - [タイトル]

### 対応したコメント

| # | ファイル | コメント | アクション | ステータス |
|---|----------|---------|-----------|-----------|
| 1 | `path/file.ts:45` | [概要] | 実装済み | 完了 |
| 2 | `path/other.ts:12` | [概要] | 議論 | 記録済み |
| 3 | `path/test.ts:78` | [概要] | 辞退 | 却下 |

### 実施した変更

| ファイル | 変更内容 |
|----------|----------|
| `path/file.ts` | [説明] |

### 投稿する回答

| コメント | 回答 |
|----------|------|
| @reviewer の file.ts:45 | [回答] |

### 検証

- [ ] テスト合格
- [ ] リント合格
- [ ] ビルド成功
- [ ] リグレッションなし

### 次のステップ

1. 変更をプッシュする
2. PR コメントに回答を投稿する
3. 再レビューをリクエストする
```

---

## コメント回答テンプレート

### 要求通りに実装

```
対応しました！[ファイル]を[変更内容の説明]に更新しました。
```

### 修正を加えて実装

```
ご指摘ありがとうございます！対応しましたが、[理由]のため[アプローチ]を採用しました。元の提案の方がよい場合はお知らせください。
```

### 説明を提供

```
このアプローチを選んだ理由は[説明]です。[代替案]も検討しましたが、[トレードオフ]のため現在のアプローチを選択しました。

このアプローチに問題がある場合はお気軽にご意見ください。
```

### 丁重にお断り

```
ご提案ありがとうございます！検討しましたが、[理由]のため現在のアプローチを維持することにしました。

[該当する場合: 将来的な改善の可能性として Issue を作成しました: #XXX]
```

### 明確化のリクエスト

```
このフィードバックについてもう少し詳しく教えていただけますか？ご意図を正確に理解したいです。

[解釈 A] と [解釈 B] のどちらをご提案でしょうか？
```

---

## ルール（L1 - ハード）

- MUST: 変更を実装する前にすべてのコメントを読む
- NEVER: レビューアーのフィードバックを説明なしに無視または却下する
- NEVER: 検証なしにプッシュする
- MUST: 既存の機能を壊さないことを検証する

## デフォルト（L2 - ソフト）

- 辞退する場合でもすべてのコメントを追跡する
- 議論項目には回答を準備する
- 関連する変更は1つのコミットにまとめる（ユーザーが別々を希望しない限り）
- レビューアーのフィードバックに感謝する

## ガイドライン（L3）

- consider: コンフリクトを最小化するためにファイル別のバッチ処理を行う
- prefer: 不同意の議論よりも提案の実装を先に行う
- consider: 大幅な変更後は再レビューをリクエストする
