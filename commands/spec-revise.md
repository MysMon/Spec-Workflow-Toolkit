---
description: "実装後のユーザー変更リクエストを処理する - 仕様書/設計書に対する影響を分析し、適切なワークフローにルーティング"
argument-hint: "[変更リクエストの説明または 'interactive']"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, AskUserQuestion, TodoWrite
---

# /spec-revise - 実装後の変更リクエストハンドラー

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

`/spec-implement` 完了後のユーザー変更リクエストを処理する。このコマンドは、元の仕様書と設計書を読み込み、リクエストされた変更の影響を分析し、適切なワークフローにルーティングする。

## 使用するタイミング

- `/spec-implement` の後でユーザーが修正を希望する場合
- 実装済み機能に対する追加や変更をユーザーがリクエストする場合
- フィードバックが元の設計に対する影響評価を必要とする場合

## 使うべきでない場合

- 実装前の場合（`/spec-plan` または `/spec-review` を使用）
- 無関係な新機能の場合（`/spec-plan` を使用）
- 緊急の本番修正の場合（`/hotfix` を使用）
- エラーのデバッグの場合（`/debug` を使用）

## フェーズ概要

1. **コンテキスト読み込み** - 仕様書、設計書、実装状態を特定して読み込む
2. **変更リクエスト収集** - ユーザーの修正リクエストを収集して明確化
3. **影響分析** - 変更が仕様書と設計書にどう影響するか分析
4. **分類とルーティング** - 適切な対応パスを決定
5. **実行** - 変更を適用するか、適切なコマンドにルーティング
6. **完了** - ドキュメントと進捗ファイルを更新

## 実行手順

---

### フェーズ 1: コンテキスト読み込み

**目標:** 仕様書、設計書、実装の現在の状態を把握する。

#### プロジェクトファイルの特定

**進捗ファイルの読み取りが許容される理由（委任不要）:**
- 進捗ファイルはオーケストレーターの状態メタデータ（プロジェクトコンテンツではない）
- ステータス確認はクイックバリデーション（通常 JSON 20行未満）
- このプロジェクトの仕様書/設計書ファイルパスを特定するために不可欠
- 仕様書/設計書のコンテンツ分析と比較してコンテキスト消費が最小
- resume.md フェーズ 3 のパターンと一貫

1. **進捗ファイルで現在のプロジェクトを確認:**
   - `.claude/workspaces/{workspace-id}/claude-progress.json` を探す
   - 仕様書と設計書のファイルパスを抽出

2. **進捗ファイルがない場合**、最近の仕様書を検索:
   - `docs/specs/` のファイルを一覧表示
   - どのプロジェクトを修正するかユーザーに確認

3. **存在のみ確認（全文は読まない）:**
   - 仕様書: Glob で `docs/specs/[feature-name].md` の存在を確認
   - 設計書: Glob で `docs/specs/[feature-name]-design.md` の存在を確認
   - レビューログ: Glob で `docs/specs/[feature-name]-review.md` の存在を確認
   - 進捗ファイル: Glob で `.claude/workspaces/{id}/claude-progress.json` の存在を確認

**読み取りと編集の区別:**
- **コンテキストのための読み取り**: オーケストレーターは仕様書/設計書を直接読み取り可（変更箇所の確認、現在値の検証等のクイックルックアップ）
- **編集・修正**: 軽微な変更でも大きな変更でも `product-manager` に委任

`subagent-contract` スキルの統一クイックルックアップ制限（3ファイル以下、ファイルあたり200行以下、合計300行以下）を参照。

**TRIVIAL 変更のみの例外**（フェーズ 5 オプション A）:
単一値の修正（タイポ、日付、バージョン番号）は Edit ツールで直接編集可。
TRIVIAL の基準: 1-2行のみに影響、意味的な変更なし、判断を必要としない。
詳細な TRIVIAL 分類と具体例はフェーズ 5 を参照。

**包括的な分析**: 常に `product-manager` または `code-architect` エージェントに委任。

**コンテキスト読み込みを `product-manager` エージェントに委任:**

```
product-manager エージェントを起動:
タスク: 修正コンテキスト用に現在のプロジェクト状態を要約
入力: 仕様書ファイルパス + 設計書ファイルパス
出力: 主要要件リスト + アーキテクチャサマリー（簡潔に）
```

**product-manager（コンテキスト読み込み）のエラーハンドリング:**
product-manager が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（主要要件のみに集中）
2. リトライも失敗した場合は**フォールバック: ファイルを直接読み取り**（`subagent-contract` の統一制限を遵守）:
   - 仕様書ファイルを直接読み取り、主要要件セクションを抽出（200行以下）
   - 設計書ファイルを直接読み取り、アーキテクチャサマリーセクションを抽出（200行以下）
   - ファイルが200行を超える場合、先頭200行を警告付きで読み取り
   - 抽出した内容を影響分析のコンテキストとして使用
   - ユーザーに警告: 「直接ファイル読み取りを使用（要約処理に失敗）」
3. 進捗ファイルに追加: `"warnings": ["Context loading via agent failed, using direct read fallback"]`
4. 利用可能なコンテキストで続行（影響分析全体をブロックしない）

エージェント出力が利用可能な場合はそれをコンテキストとして使用。

**現在の状態をユーザーに提示（エージェント出力を使用）:**
```
## 現在のプロジェクト状態

**機能:** [機能名]
**仕様書:** docs/specs/[feature-name].md
**設計書:** docs/specs/[feature-name]-design.md
**ステータス:** [進捗ファイルがあればそこから、なければ「進捗ファイルなし」]

### 主要要件（product-manager のサマリーから）
[エージェント生成のサマリー]

### アーキテクチャサマリー（product-manager のサマリーから）
[エージェント生成のサマリー]

変更リクエストを受け付ける準備ができました。
```

---

### フェーズ 2: 変更リクエスト収集

**目標:** ユーザーが何を変更したいのかを収集し、明確化する。

#### `$ARGUMENTS` に変更リクエストが含まれる場合:
- リクエストを解析
- 必要に応じて明確化に進む

#### `$ARGUMENTS` が空または "interactive" の場合:
- ユーザーに何を変更したいか確認

```
何を変更または追加しますか？

例:
- 「ユーザー一覧にページネーションを追加」
- 「認証を JWT からセッションに変更」
- 「エクスポート機能を削除」
- 「検索をもっと速く」
```

#### 明確化ループ

**重要:** リクエストが曖昧な場合は AskUserQuestion を使用すること。

| ユーザーの発言 | 確認すべき内容 |
|-----------|-----------|
| 「もっと良くして」 | どう良く？パフォーマンス？UX？信頼性？ |
| 「機能を追加して」 | どの具体的な機能？ |
| 「デザインを変更して」 | UI デザイン？アーキテクチャ？データモデル？ |
| 「遅い」 | どの操作？許容範囲は？ |
| 「何かおかしい」 | どの動作？期待値 vs 実際の値？ |

**以下が揃うまで継続:**
- 変更内容の明確な説明
- 変更が必要な理由（自明でなければ）
- 制約や希望

---

### フェーズ 3: 影響分析

**目標:** リクエストされた変更が仕様書と設計書にどう影響するかを分析する。

**2つの並列エージェントを起動:**

```
1. product-manager エージェント
   タスク: 仕様書に対する変更リクエストの分析
   入力: 変更リクエスト + 仕様書ファイル
   出力:
   - 影響を受ける要件
   - 新たに必要な要件
   - 削除すべき要件
   - スコープ評価（スコープ内 / スコープ外 / 境界）

2. code-architect エージェント
   タスク: 設計書に対する変更リクエストの分析
   入力: 変更リクエスト + 設計書ファイル + 探索の発見事項
   出力:
   - 影響を受けるコンポーネント
   - 必要なアーキテクチャ変更
   - 推定複雑度（低 / 中 / 高）
   - リスク評価
```

**両エージェントの完了を待機。**

**影響分析エージェントのエラーハンドリング:**

product-manager が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（要件への影響のみに集中）
2. リトライも失敗した場合、code-architect の出力のみで続行
3. ユーザーに警告: 「仕様への影響分析が利用できません。分類は設計への影響のみに依存します。」
4. 進捗ファイルに分析が部分的であることを記録

code-architect が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（コンポーネントマッピングのみに集中）
2. リトライも失敗した場合、product-manager の出力のみで続行
3. ユーザーに警告: 「設計への影響分析が利用できません。分類は仕様への影響のみに依存します。」
4. 進捗ファイルに分析が部分的であることを記録

両方のエージェントが失敗した場合:
1. ユーザーに通知: 「影響分析が失敗しました。分類を続行できません。」
2. オプションを提示:
   - 「両エージェントをリトライ」
   - 「キャンセルして調査」
3. 少なくとも1つの分析が成功するまでフェーズ 4 に進まない

**重要: 結果の統合を verification-specialist エージェントに委任:**

```
verification-specialist エージェントを起動:
タスク: product-manager と code-architect の影響分析を統合してクロスリファレンス
入力:
  - 変更リクエストのサマリー
  - product-manager の発見事項（仕様への影響）
  - code-architect の発見事項（設計への影響）
出力:
  - 検証済み参照付きの統合影響分析
  - 推奨分類（TRIVIAL/SMALL/MEDIUM/LARGE/NEW）
  - 各判定の信頼度スコア
  - 分析間の矛盾やギャップの特定
```

手動で結果を統合しないこと。フェーズ 4 の提示にはエージェントの統合出力を使用する。

**verification-specialist のエラーハンドリング:**
verification-specialist が失敗またはタイムアウトした場合:
1. product-manager と code-architect の発見事項を個別に提示
2. ユーザーに警告: 「影響分析の統合が失敗しました。エージェントの生の発見事項を表示します。」
3. **フォールバック: 基本的な手動分類が許可される** verification-specialist 失敗時:

   以下の簡易分類ロジックを適用:
   | 仕様への影響 | 設計への影響 | 分類 |
   |-------------|---------------|----------------|
   | 言及なし | 言及なし | TRIVIAL |
   | 「軽微」または「明確化」のみ | なし または「軽微」 | SMALL |
   | 「新しい要件」あり | いずれか | MEDIUM 以上 |
   | 「重大」または「破壊的」 | いずれか | LARGE |
   | 「スコープ外」の言及 | いずれか | NEW |

4. 信頼度の注記付きで分類をユーザーに提示:
   ```
   利用可能な分析に基づく（完全な統合なし）:
   - product-manager の発見: [仕様への影響のサマリー]
   - code-architect の発見: [設計への影響のサマリー]

   推奨分類: [TRIVIAL/SMALL/MEDIUM/LARGE/NEW]

   注: この分類は完全な統合なしで導出されました。
   続行前に確認または調整してください。

   オプション:
   1. 推奨分類で続行
   2. verification-specialist で統合をリトライ
   3. 別の分類を手動で選択
   ```

5. フォールバック分類で続行する前にユーザーの明示的な確認を必須とする

**統合分析をユーザーに提示（verification-specialist の出力を使用）:**
```markdown
## 影響分析

### 仕様への影響
- **影響を受ける要件:** [統合出力から]
- **新しい要件:** [統合出力から]
- **スコープ評価:** [統合出力から]

### 設計への影響
- **影響を受けるコンポーネント:** [統合出力から]
- **アーキテクチャ変更:** [統合出力から]
- **複雑度:** [統合出力から]
- **リスク:** [統合出力から]

### 分類
[フェーズ 4 の分類結果を参照]
```

---

### フェーズ 4: 分類とルーティング

**目標:** 影響分析に基づいて適切な対応パスを決定する。

#### 分類マトリクス

| 仕様への影響 | 設計への影響 | 分類 | ルート |
|-------------|---------------|----------------|-------|
| なし | なし/軽微 | **TRIVIAL** | 直接修正 |
| 軽微 | なし/軽微 | **SMALL** | 仕様書/設計書を編集後、`/quick-impl` |
| 軽微 | 重大 | **MEDIUM** | 設計見直しのため `/spec-review` |
| 重大 | いずれか | **LARGE** | 再計画のため `/spec-plan` |
| スコープ外 | いずれか | **NEW** | 新機能として `/spec-plan` |

#### 分類をユーザーに提示

```
## 変更分類

**リクエスト:** [サマリー]

**分類:** [TRIVIAL / SMALL / MEDIUM / LARGE / NEW]

**根拠:**
- 仕様への影響: [説明]
- 設計への影響: [説明]

**推奨アクション:**
[分類に基づく - 以下のオプションを参照]

オプション:
1. [推奨アクション] - [理由]
2. [代替アクション] - [トレードオフ]
3. 詳しく議論する - 影響についてもっと説明します
```

**重要:** 常にユーザーに選択させること。確認なしに自動ルーティングしない。

#### ルーティングアクション

**TRIVIAL（直接修正）:**
```
仕様書や設計書に影響しない軽微な変更です。
Edit ツールで直接適用できます。

修正を進めますか？
1. はい、直接変更を適用
2. 代わりに product-manager に委任
3. いいえ、再検討します
```

はいの場合（オプション 1）: フェーズ 5 オプション A（直接編集）に進む。
オプション 2 の場合: フェーズ 5 オプション B（product-manager 委任）に進む。

**SMALL（仕様書/設計書の編集 + クイック実装）:**
```
実装前に仕様書/設計書の更新が必要な変更です。

product-manager に委任して:
1. 仕様書に [変更内容] を更新
2. 設計書に [変更内容] を更新

その後 /quick-impl で実装できます。

進めますか？
```

はいの場合: フェーズ 5（product-manager 委任による SMALL 実行）に進む。

**MEDIUM（設計の見直しが必要）:**
```
アーキテクチャに大きく影響する変更です。

推奨: /spec-review を実行して、完全な分析で設計を見直します。

進捗ファイルを更新して /spec-review が以下に集中するようにします:
- [影響エリア 1]
- [影響エリア 2]

今すぐ /spec-review を実行しますか？
1. はい、設計の見直しを開始
2. いいえ、それでも進めたい（リスクあり）
3. 考えさせてください
```

はいの場合: 修正コンテキストで進捗ファイルを更新し、`/spec-review` の実行をユーザーに案内。

**LARGE（再計画が必要）:**
```
コア要件に影響する重大な変更です。

推奨: /spec-plan を実行して新しい制約で再分析します。

元の計画では [X] を前提としていましたが、変更には [Y] が必要です。
再計画により堅実な基盤を確保できます。

オプション:
1. 新しい制約で /spec-plan を実行
2. 現在の計画を適応してみる（リスク高）
3. 変更を取りやめる
```

オプション 1 の場合: 進捗ファイルを更新し、`/spec-plan` の実行をユーザーに案内。

**NEW（新機能）:**
```
このリクエストは現在の機能のスコープ外です。

別の機能として /spec-plan で計画する必要があります。

現在の機能: [名前] - [スコープサマリー]
リクエスト: [サマリー] - [スコープ外である理由]

オプション:
1. 新機能として /spec-plan を開始
2. 現在の機能に組み込む（スコープクリープのリスク）
3. 後回しにする
```

---

### フェーズ 5: 実行（TRIVIAL と SMALL のみ）

**目標:** 分類が直接アクションを許容する場合に変更を適用する。

#### TRIVIAL 変更の場合

TRIVIAL 変更とは、以下のすべての基準を満たす単一値の修正:
- 1-2行のみに影響
- 意味的な変更なし（変更前後で意味が同一）
- 判断を必要としない

基本基準は `subagent-contract` スキルの「TRIVIAL Edit Definition」、正当性は「オーケストレーター例外リファレンス」を参照。

**TRIVIAL の具体例（デフォルトは product-manager に委任）:**

| 変更タイプ | 例 | TRIVIAL の理由 |
|-------------|---------|-------------|
| タイポ修正 | "recieve" → "receive" | スペルミス、意味は同一 |
| バージョン番号 | "1.0.0" → "1.0.1" | メタデータ更新、動作変更なし |
| 日付更新 | "2025-01-01" → "2025-01-31" | メタデータ更新 |
| フォーマット | マークダウンの箇条書きインデント修正 | 見た目のみ |

**注:** 数値の変更（タイムアウト、リトライ回数、制限値）はデフォルトで TRIVIAL ではない。小さな数値変更でも仕様の意図変更を示す可能性があり、適切なコンテキスト管理のために product-manager に委任すべき。

**TRIVIAL ではない（product-manager に委任）:**

| 変更タイプ | 例 | TRIVIAL でない理由 |
|-------------|---------|-----------------|
| 動作に影響する値 | `timeout: 30` → `timeout: 600`（10倍増） | 仕様の意図変更の可能性 |
| 意味が変わる文言 | "should" → "must" | 要件の強度が変化 |
| コンテンツの追加/削除 | 新しい箇条書きの追加 | 新しい要件 |
| 要件の説明 | 「ファイルアップロード可」→「画像のみアップロード可」 | スコープ変更 |
| 意図を持つ明確化 | 「高速レスポンス」→「100ms以内のレスポンス」 | 具体性の追加 |

**グレーゾーン - 常に product-manager に委任:**

| 変更 | TRIVIAL でない理由 | アクション |
|--------|---------------------|--------|
| `maxRetries: 3` → `maxRetries: 5` | 数値変更が動作に影響 | product-manager に委任 |
| `timeout: 30` → `timeout: 60` | 数値変更が動作に影響 | product-manager に委任 |
| "error message" → "error notification" | 微妙な意味の変化 | product-manager に委任 |
| フィールドから "(optional)" を削除 | 要件ステータスの変更 | product-manager に委任 |

**経験則:** 数値に影響する変更や実装動作に影響し得る変更は、product-manager に委任する。迷ったら常に委任。

**TRIVIAL の実行オプション:**

**オプション A: product-manager に委任（推奨 - 委任優先）**
```
product-manager エージェントを起動:
タスク: 仕様書/設計書に TRIVIAL 変更を適用
変更リクエスト: [ユーザーのリクエスト]
ファイル: [仕様書および/または設計書のファイルパス]
制約: 単一値の修正のみ、意味的変更なし
出力: 変更前後の確認
```

**オプション B: 直接編集（フォールバックのみ）**
1. Edit ツールで1行の変更を適用
2. ユーザーに変更前後の差分を表示
3. `git diff` で変更範囲を確認
4. 意図した以上の行が変更された場合、元に戻して SMALL にエスカレーション

**デフォルトでオプション A を選択（委任優先の原則）。オプション B は以下の場合のみ使用:**
- ユーザーが速度のために直接編集を明示的にリクエスト
- エージェントのリトライが失敗（1回リトライ後）
- 変更が純粋なフォーマット（空白、マークダウン構文のみ）

**変更後の検証（両オプション共通）:**
- `git diff` で意図した行のみが変更されたことを確認
- より多くの行に影響した場合、ユーザーに警告して元に戻すオプションを提示

#### SMALL 変更の場合

SMALL 変更とは、以下のすべての基準を満たす軽微な編集:
- **行数制限:** 全ファイル合計で20行未満の変更
- **ファイル数制限:** 1-2ファイルのみに影響
- **アーキテクチャ影響なし:** 設計決定、データモデル、API コントラクトを変更しない
- **低リスク:** タイポ、文言改善、明確化の追加、軽微な要件追加

**重要: SMALL に分類する前に「アーキテクチャ影響なし」を検証:**
- フェーズ 3 の verification-specialist の信頼度スコアを使用
- 「アーキテクチャ影響なし」の信頼度が 90 未満: MEDIUM にエスカレーション
- verification-specialist が信頼度を提供していない場合: ユーザーに確認を求める

いずれかの基準を満たさない場合、MEDIUM にエスカレーションし `/spec-review` を推奨。

**product-manager に委任:**

```
product-manager エージェントを起動:
タスク: 仕様書と設計書に小規模な変更を適用
変更リクエスト: [ユーザーのリクエスト]
仕様書ファイル: [仕様書ファイルパス]
設計書ファイル: [設計書ファイルパス]
影響分析: [フェーズ 3 からのサマリー]
制約:
- 変更は20行未満
- アーキテクチャ変更なし
- ドキュメントの一貫性を維持
出力:
- 実施した変更のサマリー
- 変更セクションごとの変更前後
```

**エージェント出力を差分サマリーとして提示:**
```
## 適用された変更

### 仕様書の更新
[product-manager の出力から]

### 設計書の更新
[product-manager の出力から]

次のステップ: /quick-impl を実行してこれらの変更を実装してください。
```

**SMALL 実行のエラーハンドリング:**
product-manager が失敗またはタイムアウトした場合:
1. 単一ファイルにフォーカスしてリトライ（仕様書または設計書のいずれか）
2. リトライも失敗した場合、ユーザーに通知:
   ```
   小規模変更の適用が失敗しました。

   オプション:
   1. 単一ファイルスコープでリトライ
   2. MEDIUM 分類にエスカレーション（/spec-review を使用）
   3. 変更をキャンセル
   ```
3. 進捗ファイルに追加: `"warnings": ["SMALL change application failed"]`

---

### フェーズ 6: 完了

**目標:** すべての関連ファイルを更新し、次のステップを提示する。

#### 進捗ファイルの更新

```json
{
  "currentPhase": "revise-complete",
  "currentTask": "Change request processed",
  "lastUpdated": "{timestamp}",
  "resumptionContext": {
    "changeRequest": "{summary}",
    "classification": "{TRIVIAL/SMALL/MEDIUM/LARGE/NEW}",
    "action": "{実施した内容または推奨内容}",
    "nextAction": "{次に実行すべきコマンド}"
  }
}
```

#### レビューログの更新

`docs/specs/[feature-name]-review.md` に追記:
```markdown
## 修正: {date}

### 変更リクエスト
{ユーザーのリクエスト}

### 分類
{分類} - {根拠}

### 実施したアクション
{実施内容}

### 次のステップ
{推奨事項}
```

#### サマリーの提示

```
## 修正完了

**リクエスト:** {サマリー}
**分類:** {分類}
**アクション:** {実施内容}

### 次のステップ
{分類に基づく}

### 更新されたファイル
- {変更ファイルリスト}
```

---

## フィードバックループ

完了後、追加の変更を処理するか確認:

```
他に変更はありますか？
1. はい、別の変更があります
2. いいえ、今回はこれで完了です
3. 最後の変更を元に戻す
```

「はい」の場合: フェーズ 2 に戻る。
「元に戻す」の場合: git で変更を元に戻し、フェーズ 2 に戻る。

---

## 使用例

```bash
# インタラクティブモード - 会話的に変更を説明
/spec-revise

# 直接変更リクエスト
/spec-revise ユーザー一覧 API にページネーションを追加

# 具体的な修正
/spec-revise 認証トークンの有効期限を1時間から24時間に変更

# 機能の調整
/spec-revise メール通知機能を削除
```

---

## ルール（L1 - ハード）

- MUST: 包括的な仕様書/設計書分析は `product-manager` または `code-architect` エージェントに委任する
- MUST: TRIVIAL 変更はデフォルトで `product-manager` に委任する。直接 Edit はフォールバックのみ（フェーズ 5 参照）
- ALWAYS: 変更リクエストが曖昧な場合は AskUserQuestion を使用する
- NEVER: ユーザーの確認なしに他のコマンドに自動ルーティングする
- NEVER: 影響分析をスキップする - 常に両エージェントを実行
- MUST: 完了時に進捗ファイルを更新する
- MUST: レビューログに追記する
- MUST: 分類を提示し、ユーザーにアクションを選択させる

## デフォルト（L2 - ソフト）

- 影響分析のために product-manager と code-architect を並列起動
- ユーザーの理解を助けるために分類マトリクスの根拠を提示
- 完了後に追加変更のフィードバックループを提示
- MEDIUM/LARGE/NEW では適切なコマンドを推奨するが強制しない

## ガイドライン（L3）

- consider: 現在の状態を提示する際に仕様書/設計書の関連部分を表示する
- recommend: ユーザーが分類をオーバーライドしたい場合はトレードオフを説明する
- consider: ユーザーが迷っている場合は変更リクエストの後回しを提案する
