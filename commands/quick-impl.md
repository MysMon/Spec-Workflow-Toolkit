---
description: "完全な plan→review→implement フローが不要な、明確で小規模なタスクの迅速な実装"
argument-hint: "<タスクの説明>"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, AskUserQuestion, TodoWrite
---

# /quick-impl - クイック実装

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

完全な plan→review→implement フローが不要な、小規模で明確に定義されたタスク向け。以下の場合に使用する:
- タスクが明確に定義されている（曖昧でない）
- スコープが小さい（1〜3ファイル）
- アーキテクチャの判断が不要
- リスクが低い

## ガードレール

クイック実装でもコア原則は遵守する:

1. **コーディング前に理解する** - まず関連ファイルを読む
2. **変更をテストする** - 既存テストを実行し、必要に応じて追加する
3. **セキュリティチェック** - シークレットなし、脆弱性なし
4. **品質チェック** - 変更後にリント/フォーマットを実行

## 実行手順

### ステップ 1: スコープの検証（実装開始前に必ず実施）

**重要（L1）: 作業開始前にスコープを検証すること。**

これがクイックタスクに該当するか確認する:

**すべての基準を満たす場合のみ進行する:**
- [ ] `$ARGUMENTS` でタスクが明確に定義されている
- [ ] 影響するファイルが3つ以下
- [ ] データベーススキーマの変更なし
- [ ] API コントラクトの変更なし
- [ ] セキュリティに関わるコードなし

**/spec-plan にエスカレーションが必要な場合:**
- タスクが曖昧または不明確
- 複数のコンポーネントに影響
- アーキテクチャの判断が必要
- セキュリティへの影響あり

**タスクが不明確な場合は AskUserQuestion を使用すること:**

| ユーザーの発言 | 確認すべき内容 |
|----------------|----------------|
| 「バグを直して」 | どのバグか？どこで発生？期待される動作は？ |
| 「バリデーションを追加」 | どのフィールド？どのルール？エラーメッセージは？ |
| 「改善して」 | どの側面？パフォーマンス？UX？可読性？ |
| 「動くようにして」 | 何が壊れている？期待される動作は？ |

**曖昧なタスクで進行しないこと — まず明確化する。**

### ステップ 2: コンテキスト収集

**常に最初に Explore エージェントに委任する** — スコープが明確なタスクでも同様。

```
Task ツールを subagent_type=Explore で起動（quick モード）:
タスク: クイック実装のためのコンテキスト収集
対象: [ユーザーが指定したファイルまたはタスク説明]
検出:
- プロジェクトスタック検出（設定ファイルから）
- [タスク]に関連するファイル
- 類似機能の既存パターン
- 更新が必要なテストファイル
出力: スタック情報、関連ファイル、従うべきパターン、テストファイルパス
```

**委任優先（直接読み取り優先でない）理由:**
1. **コンテキスト保護**: エージェントの読み取りはオーケストレーターのコンテキストを消費しない
2. **一貫性**: spec-implement, spec-review, spec-revise と同じパターン
3. **専門性**: エージェントが stack-detector とパターン認識を適用する
4. **フォールバック安全性**: 直接読み取りはセーフティネットであり、主要パスではない

**判断基準:**
| シナリオ | アクション |
|----------|-----------|
| ユーザーが正確なファイルパスを指定 | Explore（quick モード）にファイルヒント付きで委任 |
| ユーザーが関数/クラス名を指定 | Explore（quick モード）に特定を委任 |
| タスクが曖昧（「バグを直して」） | Explore（discovery モード）に委任 |
| 影響を受けるファイルが複数 | Explore（medium thoroughness）に委任 |

**Explore エージェントのエラーハンドリング（フォールバック）:**
Explore エージェントが失敗またはタイムアウトした場合:
1. エージェントの部分的な出力に使用可能なコンテキストがないか確認する
2. **フォールバック: 直接読み取り**（ファイルが200行未満の場合）:
   - ユーザーが指定したファイルを直接読み取る
   - ユーザーに警告: 「直接ファイル読み取りを使用（エージェントがタイムアウト）」
3. 利用可能なコンテキストで実装を進行する
4. サマリーに記録: 「フォールバックでコンテキスト収集（エージェントタイムアウト）」

**パターンについて:** Explore エージェントがパターンを返した場合、ステップ 3 のスペシャリストに渡す。フォールバックを使用した場合、スペシャリストが実装中にパターンを発見する。

**重要: 実装前に発見結果をユーザーに提示すること:**

Explore エージェント完了後（またはフォールバック完了後）、ユーザーに調査結果を提示する:

```markdown
## コンテキスト調査結果

**検出されたスタック:** [例: React + TypeScript, Node.js + Express]

**関連ファイル:**
- `path/to/file1.ts` - [簡単な説明]
- `path/to/file2.ts` - [簡単な説明]

**従うべきパターン:**
- [コードベースのパターン 1]
- [コードベースのパターン 2]

**更新が必要なテストファイル:**
- `path/to/test.spec.ts`
```

AskUserQuestion で確認する:
```
Question: "これらの関連ファイルとパターンを見つけました。実装を進めてよいですか？"
Header: "コンテキスト確認"
Options:
- "はい、実装を進めてください"
- "追加コンテキストが必要（ファイルを指定）"
- "期待と異なるので、説明を修正します"
```

ユーザーが「追加コンテキストが必要」または「期待と異なる」を選んだ場合、進行前に追加情報を収集する。

### ステップ 3: 実装

**重要:** 常に適切なスペシャリストエージェントに実装を委任すること。

```
Task ツールで適切なスペシャリストを起動（単純なタスクには model: haiku）:

- フロントエンドコード → frontend-specialist
- バックエンドコード → backend-specialist
- テスト → qa-engineer

プロンプト:
クイック実装タスク。
タスク: [タスク説明]
ファイル: [関連ファイル]
パターン: [従うべき既存パターン]
テストファイル: [パス（該当する場合）]

制約:
- 既存のコードパターンに従う
- 変更スコープを最小限に保つ
```

**スペシャリストエージェントのエラーハンドリング:**
スペシャリストエージェントが失敗またはタイムアウトした場合:
1. エージェントの部分的な出力に使用可能なコードがないか確認する
2. スコープを簡略化して1回リトライする（単一ファイルにフォーカス）
3. リトライも失敗した場合、具体的なエラーとともにユーザーに通知し、選択肢を提示する:
   - 「別のアプローチで再試行する」
   - 「/spec-plan に切り替えて適切に計画する」
   - 「リスクを理解した上で手動で対応する」

**TRIVIAL な変更に限り直接修正が許可される:**
基準は `subagent-contract` スキル「TRIVIAL Edit Definition」を参照。概要:
- コメントや文字列内の一行タイプミス修正
- インポート文の追加（一行）

**注意:** 設定値の変更（例: timeout: 30 → timeout: 60）は `subagent-contract` の定義では TRIVIAL ではない — 動作に影響する可能性がある。

**委任が必要な例:**
- あらゆるロジック変更（「単純」なものでも）
- 複数ファイルの修正
- 新しい関数、クラス、モジュール
- API やインターフェースの変更
- 数値設定値の変更

### ステップ 4: 検証

クイック検証チェックリスト:

```bash
# リンターを実行（自動検出）
# テストを実行
npm test  # または pytest, go test, cargo test 等

# シークレットの確認
# （prevent_secret_leak フックにより自動）
```

### ステップ 5: サマリー

簡潔なサマリー:
- 変更内容
- 修正されたファイル
- テスト状況
- フォローアップの必要性

## 使用例

```bash
# タイプミスの修正
/quick-impl README.md のタイプミスを修正 - "recieve" を "receive" に

# 設定値の追加
/quick-impl CACHE_TTL 環境変数をデフォルト値 3600 で追加

# 簡単なリファクタリング
/quick-impl コードベース全体で getUserById を findUserById にリネーム

# 簡単なユーティリティの追加
/quick-impl 数値を USD 形式にフォーマットする formatCurrency ユーティリティ関数を追加
```

## エスカレーショントリガー

**重要（L1）: 実装中に以下のいずれかが発生した場合、直ちに停止すること:**

- スコープが想定より大きい（影響ファイルが多い）
- アーキテクチャに関する疑問が生じた
- セキュリティ上の懸念が出現した
- 要件が不明確になった

**AskUserQuestion を使用してユーザーに通知すること:**

```
Question: "このタスクは当初の想定より複雑です。理由: [理由]。どのように進めますか？"
Header: "エスカレーション"
Options:
- "/spec-plan に切り替えて適切に計画する"
- "リスクを理解した上でそのまま進行する"
- "中断して要件を再検討する"
```

**スコープが不明確になった場合は実装を続行しないこと。**

## /spec-plan との比較

| 側面 | /quick-impl | /spec-plan |
|------|-------------|------------|
| 適用場面 | 明確で小規模なタスク | 曖昧または複雑な機能 |
| フェーズ | 1（実装のみ） | 計画→レビュー→実装 |
| 仕様書 | 不要 | 必要 |
| レビュー | 基本チェック | インタラクティブ + オプションの自動レビュー |
| 所要時間 | 数分 | 数時間〜数日 |
| リスク | 低スコープのみ | あらゆる複雑さ |

---

## ルール（L1 - ハード）

スコープクリープを防止し、安全なクイック実装を確保するために重要。

- MUST: 実装開始前にスコープを検証する（ステップ 1 のすべての基準を確認）
- MUST: 以下に該当する場合は `/spec-plan` にエスカレーションする:
  - タスクが曖昧または不明確
  - 3ファイルを超える影響
  - アーキテクチャの判断が必要
  - セキュリティに関わるコード
  - データベーススキーマまたは API コントラクトの変更が必要
- NEVER: スコープが曖昧な場合に実装を開始する — まず AskUserQuestion を使用する
- MUST: 以下の場合は AskUserQuestion を使用する:
  - タスク説明に曖昧な用語（「改善」「修正」「動くように」）が含まれる
  - タスクに複数の解釈が可能
  - スコープの境界が不明確
- NEVER: ユーザーの意図を推測する — まず確認する
- MUST: 完了前にテストを実行する

## デフォルト（L2 - ソフト）

品質のために重要。適切な理由がある場合はオーバーライド可能。

- 非 TRIVIAL な変更はスペシャリストエージェントに委任する
- 変更後にリンター/フォーマッターを実行する
- 完了時に変更の簡潔なサマリーを提供する

## ガイドライン（L3）

効果的なクイック実装のための推奨事項。

- consider: 実装前にスタック検出を行う
- prefer: 変更を加える前に関連ファイルを読む
