---
description: "仕様書と設計書をユーザーとインタラクティブにレビュー・改善する - 承認されるまでフィードバックループを実施"
argument-hint: "[仕様書ファイルパスまたは機能名]"
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, AskUserQuestion, TodoWrite, TeamCreate, TaskCreate, TaskUpdate, TaskList, TaskGet, SendMessage
---

# /spec-review - インタラクティブなプランレビュー

## Language Mode

すべての出力は日本語で行う。詳細は `language-enforcement` スキルを参照。

---

仕様書と設計書をユーザーとインタラクティブにレビューする。これは**ユーザー主導のフィードバックループ**であり、ユーザーがプランを読み、フィードバックし、承認されるまでプランを修正する。

自動的な機械レビューを行うには、`--auto` を使用してフィードバックループの前に並列レビューエージェントを実行する。

## 2つのレビューモード

| モード | コマンド | 動作内容 |
|------|---------|--------------|
| **インタラクティブ**（デフォルト） | `/spec-review feature.md` | ユーザーがプランを読み、フィードバック、反復 |
| **自動 + インタラクティブ** | `/spec-review feature.md --auto` | 5エージェントが先にレビュー、その後ユーザーフィードバックループ |

## 実行手順

### ステップ 1: 仕様書と設計書の特定

**読み取りと編集の区別:**
- **参照のための読み取り**: オーケストレーターはクイックルックアップのために仕様書/設計書を直接読み取り可
- **編集・修正**: 常に product-manager エージェントに委任

**重要: オーケストレーターは仕様書/設計書を直接編集してはならない - 編集は product-manager に委任すること。**

`$ARGUMENTS` が指定された場合:
- ファイルパスの場合、Glob でファイルの存在を確認
- 機能名の場合、Glob で `docs/specs/` ディレクトリを検索

**対応する設計書も特定する:**
- 仕様書が `docs/specs/user-auth.md` の場合、Glob で `docs/specs/user-auth-design.md` を探す

引数なしの場合:
- Glob で `docs/specs/` の利用可能な仕様書を一覧表示
- どれをレビューするかユーザーに確認

**コンテンツ読み込み - ファイルサイズに応じて選択:**

統一クイックルックアップ制限は `subagent-contract` スキルを参照。

**小さいファイル（ファイルあたり200行以下、合計300行以下）の場合:**
- オーケストレーターは Read ツールで直接読み取り可（提示目的のみ）
- コンテンツをそのまま表示（統合、要約、分析をしない）
- 統合/分析が必要な場合（例: トレードオフの理解、ギャップの特定）は product-manager に委任

**大きいファイル（200行超）またはサマリーが必要な場合:**
`product-manager` エージェントに委任:
```
product-manager エージェントを起動:
タスク: レビュー提示用に仕様書と設計書を要約
入力: 仕様書ファイルパス + 設計書ファイルパス（存在する場合）
出力:
- 主要要件リスト
- アーキテクチャサマリー
- ビルド順序
- トレードオフと決定事項
```

**product-manager（コンテンツ読み込み）のエラーハンドリング:**
product-manager が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（主要要件リストのみに集中）
2. リトライも失敗した場合は**フォールバック: ファイルを直接読み取り**（`subagent-contract` の統一制限を遵守）:
   - 仕様書ファイルを直接読み取り（200行以下）
   - 設計書ファイルを直接読み取り（200行以下）
   - ファイルが200行を超える場合、先頭200行を警告付きで読み取り
   - セクションヘッダー付きで生コンテンツを提示
   - ユーザーに警告: 「部分的なコンテンツを表示（要約処理に失敗、ファイルが200行超）」
3. レビューログに警告を追加: "Content loading via agent failed, using direct read fallback"

### ステップ 2: 自動レビュー（`--auto` フラグがある場合のみ）

**`--auto` が指定された場合**、ユーザーフィードバックループの前に並列レビューエージェントを起動する。

Agent Team の検出とスポーンプロンプトテンプレートのために `team-orchestration` スキルを読み込むこと。

#### Agent Team モード（team-orchestration スキルによる自動検出）

Agent Team が利用可能な場合（TeamCreate tool が使用可能）:

**ステップ 2a: チーム作成**

TeamCreate で `spec-review-{feature-name}` チームを作成する。

TeamCreate が失敗またはツールが利用不可の場合、以下の従来パターンにフォールバックし、ユーザーに通知:

```
Agent Team モードは現在利用できません。
サブエージェント（Task tool）モードでレビューを実行します。
```

**ステップ 2b: チームメイトスポーン（3体）**

以下の 3 体を Task tool で team_name を指定してスポーンする。
各チームメイトのスポーンプロンプトは team-orchestration スキルの REFERENCE.md から取得:

```
1. security-auditor:
   subagent_type: general-purpose
   team_name: spec-review-{feature-name}
   mode: plan
   prompt: REFERENCE.md の security-auditor テンプレート
         + レビュー対象の spec/design パス

2. qa-engineer:
   subagent_type: general-purpose
   team_name: spec-review-{feature-name}
   mode: default
   prompt: REFERENCE.md の qa-engineer テンプレート
         + レビュー対象の spec/design パス

3. system-architect:
   subagent_type: general-purpose
   team_name: spec-review-{feature-name}
   mode: plan
   prompt: REFERENCE.md の system-architect テンプレート
         + レビュー対象の spec/design パス
```

**ステップ 2c: サブエージェント並列起動（2体、既存パターン）**

以下の 2 体は従来通り Task tool（チームなし）で起動:
- product-manager: 完全性レビュー
- verification-specialist: 仕様と設計の整合性チェック

ステップ 2b と 2c は並行して起動すること。

**ステップ 2d: 相互レビュー促進**

チームメイトは SendMessage で相互に発見を共有する。リーダーは以下を監視:
- security-auditor -> qa-engineer: セキュリティ発見のテスト可能性評価依頼
- system-architect -> security-auditor: 技術的妥当性の検証結果

**ステップ 2e: インサイト抽出（リーダー側処理）**

全チームメイトの完了報告（SendMessage）を受信後:

1. 各メッセージから `PATTERN` / `LEARNED` / `INSIGHT` / `DECISION` / `ANTIPATTERN` マーカーを検索
2. 発見されたマーカーごとに `insights/pending/` に JSON ファイルを Write:
   ```json
   {"id": "INS-{timestamp}", "category": "[marker-type]", "content": "[content]", "source": "team-member-[role]", "status": "pending"}
   ```
3. Confidence >= 85 の発見については verification-specialist サブエージェントで参照検証

**ステップ 2f: チームクリーンアップ**

全結果統合後:

1. 各チームメイトに shutdown_request を送信
2. チーム結果とサブエージェント結果を統合
3. ステップ 3 に進む

**Agent Team エラーリカバリ（サーキットブレイカー - 3段階判断）:**

1. **個別障害（1体無応答）- 3段階判断:**
   - **一次判断: TeammateIdle イベント受信時** → 当該チームメイトから中間報告（SendMessage）を受信済みか確認
     - 中間報告あり → 正常完了の可能性あり、結果待機を継続
     - 中間報告なし → ハングと判断、同ロールのサブエージェント（Task tool）を代替スポーン
   - **二次判断: フォールバックタイムアウト** → TeammateIdle 未受信でも以下の時間で強制タイムアウト
     - security-auditor: 7分（OWASP全項目横断+相互検証、実作業中央値6分+バッファ）
     - qa-engineer: 5分、system-architect: 5分
     - 上限キャップ: 全ロール共通10分（活動ベース延長含む）
   - → 元チームメイトに shutdown_request → 残チームはそのまま継続
   - → ユーザーに「[role] をサブエージェントに切り替えました」と通知
2. **チーム障害（2体以上無応答）**: チームモード全体をブレイク → 全チームメイトに shutdown_request → 下記の従来パターンにフォールバック（5体サブエージェント）。ログに `team-fallback-full` を記録
3. **API エラー（TeamCreate/SendMessage 失敗）**: 即時ブレイク → フォールバック通知をユーザーに表示 → 従来パターンで実行。同一セッション内でチームモードを再試行しない

**Agent Team が利用不可の場合**: 以下の従来パターンを使用（フォールバック）。

#### 従来パターン（Task tool による 5 並列レビュー）

**重要: すべてのエージェントを1つのメッセージで起動すること。**

```
1. product-manager: 完全性レビュー
2. system-architect: 技術的実現可能性レビュー（仕様書 + 設計書）
3. security-auditor: セキュリティレビュー（仕様書 + 設計書）
4. qa-engineer: 品質/テスト可能性レビュー
5. verification-specialist: 仕様書↔設計書の整合性チェック（設計書が存在する場合）
```

**自動レビューエージェントのエラーハンドリング:**

各レビューエージェント（product-manager、system-architect、security-auditor、qa-engineer）について:
エージェントが失敗またはタイムアウトした場合:
1. 部分出力で使用可能な発見事項を確認
2. スコープを縮小してリトライ
3. リトライも失敗した場合、利用可能な結果で続行しギャップを記録
4. 自動レビュー結果に警告を追加: "[エージェント] のレビューが不完全"

**重要: security-auditor の障害対応:**
security-auditor がリトライ後も失敗した場合:
1. ユーザーに明示的に警告: 「セキュリティレビューが失敗しました。セキュリティバリデーションなしで続行します。」
2. 発見事項に追加: 「手動セキュリティレビューを推奨」
3. ユーザーの了承を得て続行

全5エージェントが失敗した場合:
1. ユーザーに通知: 「自動レビューが失敗しました。自動的な発見事項を提供できません。」
2. オプションを提示:
   - 「自動レビューをリトライ」
   - 「自動レビューをスキップし、手動フィードバックループに進む」
   - 「キャンセルして調査」

**結果の統合を verification-specialist エージェントに委任:**
```
verification-specialist エージェントを起動:
タスク: 5エージェントのレビュー結果を統合
ルール:
- 信頼度でフィルタ（>= 80）
- エージェント間の重複排除（複数エージェント一致で信頼度を 10 ブースト）
- カテゴリ分類: 仕様書のみ / 設計書のみ / 両方
- 重要度でソート
出力: 信頼度スコア付きの統合発見事項リスト
```

提示にはエージェントの統合出力を使用する。手動で結果を統合しないこと。

**verification-specialist のエラーハンドリング:**
verification-specialist が失敗またはタイムアウトした場合:
1. スコープを縮小してリトライ（重複排除と重要度ソートのみに集中）
2. リトライも失敗した場合:
   - 基本的な重複排除を実行: 複数エージェントからの同一問題をグループ化
   - 2エージェント以上が報告した問題: 高信頼度として扱う（10 ブースト）
   - 1エージェントのみ報告した問題: 元の信頼度を維持
3. ユーザーに警告: 「自動レビューの統合が不完全です。基本的な重複排除を適用しました。」
4. 部分的に統合された発見事項でユーザーフィードバックループに進む

**自動レビュー結果をユーザーに提示:**
```markdown
## 自動レビュー結果

[N] 件の問題が見つかりました（[X] 件クリティカル、[Y] 件重要）。

### クリティカルな問題（>= 90）
1. **[タイトル]**（[カテゴリ]、影響範囲: [仕様書/設計書/両方]）
   [説明]
   修正案: [修正内容]

### 重要な問題（80-89）
...

これらは以下のフィードバックループに組み込まれます。
```

**以下の条件で自動修正を適用:**
- 信頼度 >= 90
- 修正が単純な追加（例: 不足している「対象外」セクションの追加）
- アーキテクチャの決定やユーザー承認済み要件を変更しない
- 自動修正した内容をユーザーに必ず通知

**以下の問題はユーザーにエスカレーション:**
- アーキテクチャやコア設計の決定を変更する問題
- ユーザー承認済みの仕様要件に矛盾する問題
- 信頼度 80-89（曖昧）の問題

### ステップ 3: ユーザーレビュー用にプランを提示

仕様書と設計書の両方（または長い文書の場合はサマリー）を表示し、ユーザーが集中できるよう**ガイド付きレビュー質問**を提供:

```
プランの準備ができました。主要なチェックポイントを順に確認します。

## ガイド付きレビュー

1. **要件**: 構築したい内容を正しく捉えていますか？
   [仕様書からの主要要件リスト]

2. **アーキテクチャ**: このアプローチはコードベースとチームに合っていますか？
   [設計書からのアプローチサマリー]

3. **ビルド順序**: この順序は現実的ですか？
   [設計書からのビルド順序]

4. **セキュリティとエッジケース**: 不足はありませんか？
   [仕様書からの主要セキュリティ項目とエッジケース]

5. **トレードオフ**: これらの選択に同意しますか？
   [設計書からのトレードオフ]

何を変更しますか？（問題なければ「承認」と回答してください）
```

### ステップ 4: ユーザーフィードバックループ

**ユーザーが承認するか終了するまでループ。**

#### 曖昧なフィードバックへの対応

**重要:** ユーザーのフィードバックが不明確、または複数の解釈が可能な場合:

1. **AskUserQuestion を使用**して構造化されたオプションを提示
2. ユーザーの意図を**推測しない**
3. 具体的なトレードオフで質問をフレーミング

AskUserQuestion が必要なシナリオ例:

| ユーザーの発言 | AskUserQuestion で確認 |
|-----------|----------------------|
| 「もっと速くして」 | 読み込み速度？レスポンス速度？ビルド速度？ |
| 「エラーハンドリングを改善して」 | どのエラー？ユーザー向けメッセージ？ロギング？リカバリ？ |
| 「複雑すぎる」 | API を簡素化？機能を削減？フェーズ分割？ |
| 「これについて確信がない」 | 何が気になるか？トレードオフ付きの代替案を提示 |

各ユーザーメッセージ後にフィードバックタイプを判断:

| ユーザーの発言 | アクション |
|-----------|--------|
| 「承認」/「問題ない」/「LGTM」 | ループ終了 → ステップ 5 |
| 具体的な変更依頼（例: 「JWT ではなくセッションを使用」） | 変更を適用 → 影響セクションを再提示 |
| 質問（例: 「なぜ PostgreSQL を選んだの？」） | 設計の根拠から回答、変更したいか確認 |
| 「X を追加して」（新しい要件） | 仕様書に追加、設計書の更新が必要か確認 |
| 「X を削除して」 | 仕様書から削除、設計書の更新が必要か確認 |
| 「X について確信がない」 | トレードオフを議論、関連する代替案があれば提示 |
| 「最初からやり直して」/「再計画して」 | `/spec-plan` の再実行を提案 |

#### アーキテクチャに影響する変更への対応

**重要: オーケストレーターは仕様書/設計書を直接編集しない。常に委任すること。**

**変更が小さい場合**（文言、エッジケースの追加、要件の明確化）:

product-manager に委任:
```
product-manager エージェントを起動:
タスク: レビュー中に仕様書/設計書に小さな変更を適用
変更依頼: [ユーザーのフィードバック]
仕様書ファイル: [仕様書ファイルパス]
設計書ファイル: [設計書ファイルパス]（該当する場合）
制約: 文言/明確化のみ、アーキテクチャ変更なし
出力: 変更前後のサマリー
```

エージェント出力を使って変更セクションを再提示する。

**変更がアーキテクチャの再設計を必要とする場合**（例: 「別のデータベースを使用」、「認証アプローチを変更」）:
1. ユーザーに通知: 「この変更はアーキテクチャ設計に影響します。2つの選択肢があります:」
   - **オプション A**: code-architect に設計分析を委任し、その後 product-manager に編集を委任（ベストエフォート、再探索なし）
   - **オプション B**: 新しい制約で `/spec-plan` を再実行し、徹底的に再分析
2. オプション A の場合:
   - code-architect エージェントに設計修正分析を委任
   - code-architect の出力を使って product-manager エージェントに実際の編集を委任
   - 更新された設計を再提示、ループ継続
3. オプション B の場合: 進捗ファイルを更新、終了、`/spec-plan` コマンドの実行を提案

#### 各変更後

変更を適用した後:
```
[仕様書/設計書/両方] を更新しました。変更内容:

[変更のサマリー]

他に変更はありますか？（完了する場合は「承認」と回答してください）
```

### ステップ 5: 承認とハンドオフ

ユーザーが承認した場合:

1. **仕様書と設計書の最終版を保存**
2. **レビューログを保存** `docs/specs/[feature-name]-review.md`:
   ```markdown
   ## レビューログ: [機能名]

   ### レビューモード
   [インタラクティブ / 自動 + インタラクティブ]

   ### 実施した変更
   1. [変更内容]（ユーザーの依頼）
   2. [変更内容]（自動レビューによる修正）
   ...

   ### 自動レビューの問題（--auto を使用した場合）
   - 解決済み: [N]
   - 保留: [N]

   ### 判定
   ユーザーにより承認
   ```

3. **進捗ファイルを更新**:
   ```json
   {
     "currentPhase": "review-complete",
     "currentTask": "Review complete - approved by user",
     "resumptionContext": {
       "nextAction": "Run /spec-implement to begin implementation",
       "reviewVerdict": "APPROVED",
       "changesApplied": [N]
     }
   }
   ```

4. **次のステップを提示:**
   ```
   プランが承認されました。`/spec-implement docs/specs/[feature-name].md` を実行して構築を開始してください。
   ```

## 使用例

```bash
# インタラクティブレビュー（ユーザーフィードバックのみ）
/spec-review docs/specs/user-authentication.md

# 自動レビュー後にユーザーフィードバック
/spec-review docs/specs/user-authentication.md --auto

# 機能名でレビュー
/spec-review user-authentication

# インタラクティブ - 一覧から選択
/spec-review
```

---

## ルール（L1 - ハード）

- MUST: ガイド付きレビュー質問を提示する（単に「フィードバックはありますか？」と聞かない）
- MUST: ユーザーが明示的に承認するか終了するまでループする
- NEVER: アーキテクチャやユーザー承認済み要件に影響する変更を自動修正する
- MUST: 完了時に進捗ファイルを更新する
- MUST: レビューログを保存する
- MUST: 以下の場合は AskUserQuestion を使用する:
  - ユーザーのフィードバックに複数の解釈が可能
  - トレードオフの選択が必要な決定（例: 「X と Y のどちらを優先すべきか？」）
  - 仕様書や設計書の変更前に明確化が必要
- NEVER: フィードバックが曖昧な場合、ユーザーの意図を推測する — まず確認
- MUST: Agent Team が利用不可の場合（TeamCreate ツールにアクセスできない場合）は Task tool パターンにフォールバックする
- NEVER: チームメンバーがユーザーに直接質問することを許可する — すべてのユーザーインタラクションはリーダーが AskUserQuestion を通じて行う

## デフォルト（L2 - ソフト）

- 初回パスではフルのガイド付きレビューを提示。以降のパスでは変更セクションのみ表示
- `--auto` モードでは、アーキテクチャを変更しない信頼度 >= 90 の修正を適用
- レビューログを docs/specs/[feature-name]-review.md に保存
- 複数エージェントが一致した場合、自動レビューの信頼度を 10 ブースト

## ガイドライン（L3）

- consider: ユーザーが迷っている場合は代替案を提示する
- consider: 大きな仕様書/設計書の場合、すべてを表示するのではなくセクションを要約する
